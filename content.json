{"meta":{"title":"凌晨九点空间","subtitle":"Dawn at Nine","description":"分享知识、分享经验、分享观点","author":"凌晨九点","url":"https://lcjd99.github.io","root":"/"},"pages":[{"title":"tags","date":"2024-04-02T15:37:45.000Z","updated":"2024-04-02T15:37:45.780Z","comments":true,"path":"tags/index.html","permalink":"https://lcjd99.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-04-02T15:36:31.000Z","updated":"2024-04-02T15:41:54.089Z","comments":true,"path":"categories/index.html","permalink":"https://lcjd99.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言格式化输出问题","slug":"review-language/c-review","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-04T15:11:14.816Z","comments":true,"path":"others/review-language/c-review/","permalink":"https://lcjd99.github.io/others/review-language/c-review/","excerpt":"","text":"在日常使用中C语言时，对于命令行工具输出格式化控制非常重要，虽然每天都在用printf但是对其具体的使用还是很容易忘记，于是做如下总结 在 C 语言中，格式化打印主要通过 printf、sprintf、snprintf、fprintf 等函数实现，它们都使用格式字符串来指定输出数据的类型和格式。格式字符串由普通字符和格式指定符组成，格式指定符用来指定随后参数的打印方式。 常用的格式指定符： %d：输出有符号十进制整数。 %u：输出无符号十进制整数。 %x 或 %X：输出十六进制整数，%x 输出小写字母，%X 输出大写字母。 %o：输出八进制整数。 %f：输出浮点数。 %e 或 %E：输出指数形式的浮点数，%e 使用小写 e，%E 使用大写 E。 %g 或 %G：输出浮点数，自动选择 %f 或 %e&#x2F;%E 的格式，取决于数值的大小。 %c：输出单个字符。 %s：输出字符串。 %p：输出指针的值（十六进制表示）。 %%：输出一个百分号 %。 除了上述基本的格式指定符，还可以在 % 和格式字符之间插入一些标志、宽度、精度等修饰符： 标志方式 标志： -：左对齐输出。 +：输出数值的正负号。 （空格）：如果第一个字符不是正负号，则在该字符前添加一个空格。 #：对于 %o、%x、%X，添加前缀 0、0x、0X；对于 %f、%e、%E，强制显示小数点；对于 %g、%G，防止尾部零被删除。 0：用零填充空位。 宽度和精度 宽度：指定输出字段的最小宽度。如果输出小于这个宽度，会在左边或右边填充空格或零（取决于是否使用了 - 或 0 标志）。 精度： 对于 %f、%e、%E，精度表示小数点后的数字位数。 对于 %g、%G，精度表示有效数字的最大位数。 对于 %s，精度表示输出字符串的最大长度。 对于整数类型，精度表示最小数字位数，不足部分会填充零。 例子123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int i = 42; float f = 3.14159; char s[] = &quot;Hello, World!&quot;; printf(&quot;Integer: %d\\n&quot;, i); // 基本整型输出 printf(&quot;Integer with width: %10d\\n&quot;, i); // 宽度为10，右对齐 printf(&quot;Integer with width and zero padding: %010d\\n&quot;, i); // 宽度为10，用零填充 printf(&quot;Float: %f\\n&quot;, f); // 基本浮点数输出 printf(&quot;Float with precision: %.2f\\n&quot;, f); // 保留两位小数 printf(&quot;String: %s\\n&quot;, s); // 字符串输出 printf(&quot;String with precision: %.5s\\n&quot;, s); // 只输出字符串的前5个字符 return 0;&#125; 注意事项 确保格式指定符与提供的参数类型相匹配，否则可能会导致未定义的行为。 使用 %s 输出字符串时，确保字符串以 null 结尾，否则可能会读取到不确定的数据。 使用 % 打印百分号时，需要写成 %%。 注意 printf 家族函数的安全性问题，如缓冲区溢出。建议使用 snprintf 或 fgets/fputs 来避免这类问题。","categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"【CS61C】Lab2 实验解析","slug":"cs61c/Lab2","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-04T15:29:06.815Z","comments":true,"path":"CS61C/cs61c/Lab2/","permalink":"https://lcjd99.github.io/CS61C/cs61c/Lab2/","excerpt":"","text":"前言本人学习的是 2020 fall版的CS61C，本文将对Lab2解题思路做大致介绍，具体代码可以参考我的仓库 解题思路Exercise 1: Bit Operations三道位运算的题目中值得一说的是第二道，函数接口如下 123// Set the nth bit of the value of x to v.// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1void set_bit(unsigned * x, unsigned n, unsigned v); 题目限制如下 You may ONLY use bitwise operations such as and (&amp;), or (|), xor (^), not (~), left shifts («), and right shifts (»). You may not use any for&#x2F;while loops or conditional statements. You also may not use modulo (%), division, addition subtraction, or multiplication for this question. 我的解题思路是: 首先分析只有当需要变化的位$x_n$和$n$不同时才会发生改变。 需要通过位运算找到位反转的方式和判断不同的方式 位反转：通过异或实现 判断不同： 通过移位到最低位比较得到 具体代码如下 1234void set_bit(unsigned * x, unsigned n, unsigned v) &#123; unsigned bit = ((*x) &gt;&gt; n) &amp; 1; (*x) ^= ((bit ^ v) &lt;&lt; n);&#125;","categories":[{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"重新学习C语言内存管理","slug":"cs61c/C-and-memory","date":"2024-04-03T14:50:47.000Z","updated":"2024-04-04T14:58:09.874Z","comments":true,"path":"CS61C/cs61c/C-and-memory/","permalink":"https://lcjd99.github.io/CS61C/cs61c/C-and-memory/","excerpt":"","text":"前言在学习完操作系统MIT6.828后重新学习C语言的内存管理问题。 关于标准库 malloc 和 free在C标准库中对内存的管理是通过为每个空闲内存提供一个小的数据结构来管理的，大致的伪代码如下 1234struct block &#123; int size; //内存块的大小 struct block* next; //下一个内存块的指针&#125; 也就是说这是一个记录空闲空间的循环链表(自己实现的JOS实际上也是这样管理内存)。 malloc 的过程malloc 会根据申请内存的大小，在其中找到一个足够大的块，将这个块移出链表，并将指针返回。如果没有足够大的块，就会像操作系统申请空间，如果仍然无法满足会返回分配失败 在malloc的过程中还存在多个块满足条件如何选择的问题，此时会涉及到三种策略： best-fit ： 分配大小最合适的块 firtst-fit ： 分配最先找到的满足条件的块 next-fit ： 在每次遍历过程中记录位置，分配记录位置后下一个满足的块 free 的过程free 会将参数中指定的内存块加入到空闲块链表中，同时检查临近(物理空间)的块是否空闲，如果空闲会合并为一个更大的块。 使用时注意 malloc 二维数组的时候首先分配一维的指针，在循环分配空间，不能分配连续的空间","categories":[{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"SEUForum 技术栈","slug":"SEUForum-Stack","date":"2024-04-02T15:52:47.000Z","updated":"2024-04-03T14:47:34.150Z","comments":true,"path":"Project/SEUForum-Stack/","permalink":"https://lcjd99.github.io/Project/SEUForum-Stack/","excerpt":"","text":"本项目全栈使用 JavaScript 实现","categories":[{"name":"Project","slug":"Project","permalink":"https://lcjd99.github.io/categories/Project/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lcjd99.github.io/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-02T14:40:19.535Z","updated":"2024-04-02T15:38:52.847Z","comments":true,"path":"test/hello-world/","permalink":"https://lcjd99.github.io/test/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"https://lcjd99.github.io/categories/test/"}],"tags":[]},{"title":"git 入门教程（一）：基本用法","slug":"utils/git-1","date":"2023-10-03T14:50:47.000Z","updated":"2024-04-09T16:29:23.432Z","comments":true,"path":"git/utils/git-1/","permalink":"https://lcjd99.github.io/git/utils/git-1/","excerpt":"","text":"Git是一个免费的开源分布式版本控制系统，旨在以快速和高效的方式处理项目的所有内容。 本博客是对 pro git 的学习笔记 ，并配合一些自己使用的理解。 一 、基本模型在这一篇文章不会对git的模型进行深入的介绍，读者只需要知道当前目录暂存区(stage)、本地提交区(暂时这样表示)就可以了。 git在创建仓库后对版本控制的操作都需要通过添加暂存区后再提交。假如当前目录中有大量文件被修改，而为保证结构清晰，需要分别成多次快照的保存，就可以分别添加到暂存区再提交。 二、 基本命令以下命令直接以git [command] -h的格式就可以看到参数使用规则 2.1 基本的基本创建仓库1git init 该命令创建一个新的git仓库，其原理会在下一篇文章中说明。 添加暂存区1git add &lt;files&gt; 通过此命令可以将指定文件或者目录添加到暂存区。 tldr 使用git add . 快速添加当前目录下全部修改文件到暂存区 提交暂存区内容1git commit 这里需要说明的是每次commit的都需要有相应的信息，表示本次提交对代码的修改，git会自动打开默认的编辑器在你填写完提交信息后关闭即可。 tldr 使用git commit -m &quot;text&quot; 可以直接添加简单的提交信息而不打开编辑器 使用git commit -a 提交所有修改的文件 2.2 查看提交历史可以查看仓库的完整提交历史 1git log tldr 使用git log -p -2 查看最近两次提交的修改 使用git log --stat 统计每次的变更信息 使用git log --pretty=oneline 查看一行信息 2.3 查看当前仓库状态这里借用 pro git 中对仓库状态转移的图描述其过程 1git status tldr 使用git status -s 可以查看简短的文件状态信息 使用*.gitignore*文件可以配置不被git追踪的文件(支持正则表达式) 2.4 回滚文件重做提交如果你认为上一次提交并不完整，你可以使用： 1git commit --amend 该命令将暂存区和上次提交的信息一起提交，并进入修改信息的编辑器界面 重做暂存区如果将将暂存区中的某个文件移出暂存区可以使用： 1git reset HEAD &lt;file&gt; 文件状态回滚这是有风险的操作，被回滚的操作无法撤回 如果你不希望文件的修改，并希望上次提交状态可以使用： 1git restore &lt;file&gt; 或者 1git checkout -- &lt;file&gt; 2.5 分支管理创建分支每次提交都像链表一样被记录，而分支就像是从链表中分岔出的一条路，最后能合并回这个主路上。这样使用的理由也很简单，就像是支线任务。 1git branch &lt;branchName&gt; tldr 使用git branch -a查看所有分支 使用git branch -d &lt;branchName&gt;删除指定分支 切换分支创建分支后实际上还在原来的分支中，需要切换到指定的分支中 1git checkout &lt;branchName&gt; tldr 使用git checkout -b &lt;branchName&gt;可以直接新建并切换到新的分支 合并分支当需要将一个分支和另一个分支合并时就会用到合并分支的功能 1git merge &lt;branchName&gt; 表示将该分支合并到当前分支中 这其中可能会产生冲突， 2.5 远程仓库管理克隆仓库当需要使用远程仓库的时候需要克隆仓库，这里的远程仓库地址未必是一个url也可以是在同一文件系统下的另一个目录 1git clone &lt;repo&gt; [your_repo_name] 通过以上能够克隆一个完整仓库到指定目录下，需要注意在克隆时路径下不能有相同文件名的目录。 如果仓库是克隆的，那该仓库会有一个默认origin的远程仓库地址 1git remote 上述命令可以查看本仓库的远程仓库 tldr 使用git remote show &lt;name&gt; 查看远程仓库的完整信息 使用git remote get-url &lt;name&gt; 可以查看指定远程仓库的url 使用git remote set-url &lt;name&gt; &lt;url&gt; 可以为添加指定远程仓库的url 远程拉取当远程仓库更新后，我们也要积极更新本地仓库以保证和远程同步 1git fetch &lt;remote&gt; 该操作并不会将远程仓库更新的代码自动合并到当前分支中，而是将远程仓库中的分支作为一个本地分支存储，需要手动将远程分支合并到当前分支中（具体操作同合并分支） 也可以使用 git pull 能够将上述操作同时执行，拉取并合并。 远程推送当需要将本地提交的代码推送到远程仓库中时需要使用以下： 1git push &lt;remote&gt; &lt;branch&gt; 该指令将本地的指定分支推送到远程仓库中","categories":[{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"}]}],"categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"},{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"},{"name":"Project","slug":"Project","permalink":"https://lcjd99.github.io/categories/Project/"},{"name":"test","slug":"test","permalink":"https://lcjd99.github.io/categories/test/"},{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://lcjd99.github.io/tags/JavaScript/"},{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"}]}