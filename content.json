{"meta":{"title":"凌晨九点空间","subtitle":"Dawn at Nine","description":"分享知识、分享经验、分享观点","author":"凌晨九点","url":"https://lcjd99.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-04-02T15:36:31.000Z","updated":"2024-04-02T15:41:54.089Z","comments":true,"path":"categories/index.html","permalink":"https://lcjd99.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-04-02T15:37:45.000Z","updated":"2024-04-02T15:37:45.780Z","comments":true,"path":"tags/index.html","permalink":"https://lcjd99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux中对网络并发处理的技术","slug":"Linux/concurrent-in-linux","date":"2024-04-10T09:15:47.000Z","updated":"2024-04-10T10:03:34.502Z","comments":true,"path":"Linux/concurrent-in-linux/","permalink":"https://lcjd99.github.io/Linux/concurrent-in-linux/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lcjd99.github.io/categories/Linux/"}],"tags":[{"name":"Linux Network","slug":"Linux-Network","permalink":"https://lcjd99.github.io/tags/Linux-Network/"}]},{"title":"git 入门教程（一）：基本用法","slug":"utils/git-1","date":"2024-04-09T14:50:47.000Z","updated":"2024-04-10T09:05:11.636Z","comments":true,"path":"utils/git-1/","permalink":"https://lcjd99.github.io/utils/git-1/","excerpt":"","text":"Git是一个免费的开源分布式版本控制系统，旨在以快速和高效的方式处理项目的所有内容。 本博客是对 pro git 的学习笔记 ，并配合一些自己使用的理解。 一 、基本模型 在这一篇文章不会对git的模型进行深入的介绍，读者只需要知道当前目录暂存区(stage)、本地提交区(暂时这样表示)就可以了。 git在创建仓库后对版本控制的操作都需要通过添加暂存区后再提交。假如当前目录中有大量文件被修改，而为保证结构清晰，需要分别成多次快照的保存，就可以分别添加到暂存区再提交。 二、 基本命令 以下命令直接以git [command] -h的格式就可以看到参数使用规则 2.1 基本的基本 创建仓库 1git init 该命令创建一个新的git仓库，其原理会在下一篇文章中说明。 添加暂存区 1git add &lt;files&gt; 通过此命令可以将指定文件或者目录添加到暂存区。 tldr 使用git add . 快速添加当前目录下全部修改文件到暂存区 提交暂存区内容 1git commit 这里需要说明的是每次commit的都需要有相应的信息，表示本次提交对代码的修改，git会自动打开默认的编辑器在你填写完提交信息后关闭即可。 tldr 使用git commit -m &quot;text&quot; 可以直接添加简单的提交信息而不打开编辑器 使用git commit -a 提交所有修改的文件 2.2 查看提交历史 可以查看仓库的完整提交历史 1git log tldr 使用git log -p -2 查看最近两次提交的修改 使用git log --stat 统计每次的变更信息 使用git log --pretty=oneline 查看一行信息 2.3 查看当前仓库状态 这里借用 pro git 中对仓库状态转移的图描述其过程 1git status tldr 使用git status -s 可以查看简短的文件状态信息 使用*.gitignore*文件可以配置不被git追踪的文件(支持正则表达式) 2.4 回滚文件 重做提交 如果你认为上一次提交并不完整，你可以使用： 1git commit --amend 该命令将暂存区和上次提交的信息一起提交，并进入修改信息的编辑器界面 重做暂存区 如果将将暂存区中的某个文件移出暂存区可以使用： 1git reset HEAD &lt;file&gt; 文件状态回滚 这是有风险的操作，被回滚的操作无法撤回 如果你不希望文件的修改，并希望上次提交状态可以使用： 1git restore &lt;file&gt; 或者 1git checkout -- &lt;file&gt; 2.5 分支管理 创建分支 每次提交都像链表一样被记录，而分支就像是从链表中分岔出的一条路，最后能合并回这个主路上。这样使用的理由也很简单，就像是支线任务。 1git branch &lt;branchName&gt; tldr 使用git branch -a查看所有分支 使用git branch -d &lt;branchName&gt;删除指定分支 切换分支 创建分支后实际上还在原来的分支中，需要切换到指定的分支中 1git checkout &lt;branchName&gt; tldr 使用git checkout -b &lt;branchName&gt;可以直接新建并切换到新的分支 合并分支 当需要将一个分支和另一个分支合并时就会用到合并分支的功能 1git merge &lt;branchName&gt; 表示将该分支合并到当前分支中 这其中可能会产生冲突， 2.5 远程仓库管理 克隆仓库 当需要使用远程仓库的时候需要克隆仓库，这里的远程仓库地址未必是一个url也可以是在同一文件系统下的另一个目录 1git clone &lt;repo&gt; [your_repo_name] 通过以上能够克隆一个完整仓库到指定目录下，需要注意在克隆时路径下不能有相同文件名的目录。 如果仓库是克隆的，那该仓库会有一个默认origin的远程仓库地址 1git remote 上述命令可以查看本仓库的远程仓库 tldr 使用git remote show &lt;name&gt; 查看远程仓库的完整信息 使用git remote get-url &lt;name&gt; 可以查看指定远程仓库的url 使用git remote set-url &lt;name&gt; &lt;url&gt; 可以为添加指定远程仓库的url 远程拉取 当远程仓库更新后，我们也要积极更新本地仓库以保证和远程同步 1git fetch &lt;remote&gt; 该操作并不会将远程仓库更新的代码自动合并到当前分支中，而是将远程仓库中的分支作为一个本地分支存储，需要手动将远程分支合并到当前分支中（具体操作同合并分支） 也可以使用 git pull 能够将上述操作同时执行，拉取并合并。 远程推送 当需要将本地提交的代码推送到远程仓库中时需要使用以下： 1git push &lt;remote&gt; &lt;branch&gt; 该指令将本地的指定分支推送到远程仓库中","categories":[{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"}]},{"title":"C语言格式化输出问题","slug":"others/c-format-output","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-10T09:12:21.579Z","comments":true,"path":"others/c-format-output/","permalink":"https://lcjd99.github.io/others/c-format-output/","excerpt":"","text":"在日常使用中C语言时，对于命令行工具输出格式化控制非常重要，虽然每天都在用printf但是对其具体的使用还是很容易忘记，于是做如下总结 在 C 语言中，格式化打印主要通过 printf、sprintf、snprintf、fprintf 等函数实现，它们都使用格式字符串来指定输出数据的类型和格式。格式字符串由普通字符和格式指定符组成，格式指定符用来指定随后参数的打印方式。 常用的格式指定符： %d：输出有符号十进制整数。 %u：输出无符号十进制整数。 %x 或 %X：输出十六进制整数，%x 输出小写字母，%X 输出大写字母。 %o：输出八进制整数。 %f：输出浮点数。 %e 或 %E：输出指数形式的浮点数，%e 使用小写 e，%E 使用大写 E。 %g 或 %G：输出浮点数，自动选择 %f 或 %e/%E 的格式，取决于数值的大小。 %c：输出单个字符。 %s：输出字符串。 %p：输出指针的值（十六进制表示）。 %%：输出一个百分号 %。 除了上述基本的格式指定符，还可以在 % 和格式字符之间插入一些标志、宽度、精度等修饰符： 标志方式 标志： -：左对齐输出。 +：输出数值的正负号。 （空格）：如果第一个字符不是正负号，则在该字符前添加一个空格。 #：对于 %o、%x、%X，添加前缀 0、0x、0X；对于 %f、%e、%E，强制显示小数点；对于 %g、%G，防止尾部零被删除。 0：用零填充空位。 宽度和精度 宽度：指定输出字段的最小宽度。如果输出小于这个宽度，会在左边或右边填充空格或零（取决于是否使用了 - 或 0 标志）。 精度： 对于 %f、%e、%E，精度表示小数点后的数字位数。 对于 %g、%G，精度表示有效数字的最大位数。 对于 %s，精度表示输出字符串的最大长度。 对于整数类型，精度表示最小数字位数，不足部分会填充零。 例子 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int i = 42; float f = 3.14159; char s[] = &quot;Hello, World!&quot;; printf(&quot;Integer: %d\\n&quot;, i); // 基本整型输出 printf(&quot;Integer with width: %10d\\n&quot;, i); // 宽度为10，右对齐 printf(&quot;Integer with width and zero padding: %010d\\n&quot;, i); // 宽度为10，用零填充 printf(&quot;Float: %f\\n&quot;, f); // 基本浮点数输出 printf(&quot;Float with precision: %.2f\\n&quot;, f); // 保留两位小数 printf(&quot;String: %s\\n&quot;, s); // 字符串输出 printf(&quot;String with precision: %.5s\\n&quot;, s); // 只输出字符串的前5个字符 return 0;&#125; 注意事项 确保格式指定符与提供的参数类型相匹配，否则可能会导致未定义的行为。 使用 %s 输出字符串时，确保字符串以 null 结尾，否则可能会读取到不确定的数据。 使用 % 打印百分号时，需要写成 %%。 注意 printf 家族函数的安全性问题，如缓冲区溢出。建议使用 snprintf 或 fgets/fputs 来避免这类问题。","categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"【CS61C】Lab2 实验解析","slug":"Course/cs61c/Lab2","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-12T15:29:05.478Z","comments":true,"path":"Course/cs61c/Lab2/","permalink":"https://lcjd99.github.io/Course/cs61c/Lab2/","excerpt":"","text":"前言 本人学习的是 2020 fall版的CS61C，本文将对Lab2解题思路做大致介绍，具体代码可以参考我的仓库 解题思路 Exercise 1: Bit Operations 三道位运算的题目中值得一说的是第二道，函数接口如下 123// Set the nth bit of the value of x to v.// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1void set_bit(unsigned * x, unsigned n, unsigned v); 题目限制如下 You may ONLY use bitwise operations such as and (&amp;), or (|), xor (^), not (~), left shifts («), and right shifts (»). You may not use any for/while loops or conditional statements. You also may not use modulo (%), division, addition subtraction, or multiplication for this question. 我的解题思路是: 首先分析只有当需要变化的位xnx_nxn​和nnn不同时才会发生改变。 需要通过位运算找到位反转的方式和判断不同的方式 位反转：通过异或实现 判断不同： 通过移位到最低位比较得到 具体代码如下 1234void set_bit(unsigned * x, unsigned n, unsigned v) &#123; unsigned bit = ((*x) &gt;&gt; n) &amp; 1; (*x) ^= ((bit ^ v) &lt;&lt; n);&#125;","categories":[{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]},{"title":"【考研】计组 （二）： 数据的表示和运算","slug":"Postgraduate/CS/Organization/Lecture2","date":"2024-04-04T14:51:47.000Z","updated":"2024-04-12T15:25:17.818Z","comments":true,"path":"Postgraduate/CS/Organization/Lecture2/","permalink":"https://lcjd99.github.io/Postgraduate/CS/Organization/Lecture2/","excerpt":"","text":"经过做题的实践发现，对于原码、补码、移码等运算除了掌握计算机基本的运算规则以外还有一些共性的规律，利用这些规律可以更快速的解题，将我总结的规律记录如下。 一、定点数编码解题技巧 1.0 一些常识 28=2562^8 = 25628=256 216=655362^{16} = 65536216=65536 8位数最大表示为 27−12^7 - 127−1，计算机中始终从0位开始数 相同位数的补码和移码表示的数据范围相同 1.1 补码的规律 一个8位的数用补码表示其表示范围是 2−72^{-7}2−7 到 27−12^{7} - 127−1 思考方式：补码不对称，0将正数的一个位置占了，因此正数少一个， 同时 777 位最多表示 272^727 个数，应此得到这个结果 一个8位的负数通过补码计算真值的时候如果这个数除符号位的部分容易确定大小，可以直接用公式 −(28−m)-(2^8 - m)−(28−m) 得到结果，其中mmm 是这个正数。 思考方式： 这个实际上是补码的定义，有时候比化成反码再算要快 补码的数值变化规律： 实际上是两个递增的一次函数，其中断点在000 处， 在单调区间内可以直接比较大小 思考方式： 别想了，容易倒腾乱 有符号数和无符号数的转化关系，具体例子如下 123short a = -32767;unsigned short b = a;printf(&quot;%d\\n&quot;, b); 对于这个问题求解为 $b = 2^{16} - |a| $ 思考方法： $ a = 2^{15} - |m|$ ， 同时 b=215+∣m∣b = 2^{15} + |m|b=215+∣m∣ , 其中 mmm 就是除最高位的表示数 1.2 移码的规律 偏移为127的移码","categories":[{"name":"考研","slug":"考研","permalink":"https://lcjd99.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"Computer Organization","slug":"Computer-Organization","permalink":"https://lcjd99.github.io/tags/Computer-Organization/"}]},{"title":"重新学习C语言内存管理","slug":"others/c-and-memory","date":"2024-04-03T14:50:47.000Z","updated":"2024-04-10T09:12:38.701Z","comments":true,"path":"others/c-and-memory/","permalink":"https://lcjd99.github.io/others/c-and-memory/","excerpt":"","text":"前言 在学习完操作系统MIT6.828后重新学习C语言的内存管理问题。 关于标准库 malloc 和 free 在C标准库中对内存的管理是通过为每个空闲内存提供一个小的数据结构来管理的，大致的伪代码如下 1234struct block &#123; int size; //内存块的大小 struct block* next; //下一个内存块的指针&#125; 也就是说这是一个记录空闲空间的循环链表(自己实现的JOS实际上也是这样管理内存)。 malloc 的过程 malloc 会根据申请内存的大小，在其中找到一个足够大的块，将这个块移出链表，并将指针返回。如果没有足够大的块，就会像操作系统申请空间，如果仍然无法满足会返回分配失败 在malloc的过程中还存在多个块满足条件如何选择的问题，此时会涉及到三种策略： best-fit ： 分配大小最合适的块 firtst-fit ： 分配最先找到的满足条件的块 next-fit ： 在每次遍历过程中记录位置，分配记录位置后下一个满足的块 free 的过程 free 会将参数中指定的内存块加入到空闲块链表中，同时检查临近(物理空间)的块是否空闲，如果空闲会合并为一个更大的块。 使用时注意 malloc 二维数组的时候首先分配一维的指针，在循环分配空间，不能分配连续的空间","categories":[{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"}],"tags":[{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://lcjd99.github.io/categories/Linux/"},{"name":"git","slug":"git","permalink":"https://lcjd99.github.io/categories/git/"},{"name":"others","slug":"others","permalink":"https://lcjd99.github.io/categories/others/"},{"name":"CS61C","slug":"CS61C","permalink":"https://lcjd99.github.io/categories/CS61C/"},{"name":"考研","slug":"考研","permalink":"https://lcjd99.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"Linux Network","slug":"Linux-Network","permalink":"https://lcjd99.github.io/tags/Linux-Network/"},{"name":"utils","slug":"utils","permalink":"https://lcjd99.github.io/tags/utils/"},{"name":"C","slug":"C","permalink":"https://lcjd99.github.io/tags/C/"},{"name":"Computer Organization","slug":"Computer-Organization","permalink":"https://lcjd99.github.io/tags/Computer-Organization/"}]}